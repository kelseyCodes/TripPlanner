(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports =
    angular.module('grid', [
        require('./angular-decorator').name,
        require('./angular-builder').name
    ])
    .factory('GridSrvc', function() {
        return {
            core: require('./core')
        };
    });
},{"./angular-builder":13,"./angular-decorator":14,"./core":22}],2:[function(require,module,exports){
module.exports = function (string) {
  return string.charAt(0).toUpperCase() + string.substring(1);
}

module.exports.words = function (string) {
  return string.replace(/(^|\W)(\w)/g, function (m) {
    return m.toUpperCase()
  })
}

},{}],3:[function(require,module,exports){
module.exports = function(opts) {
  return new ElementClass(opts)
}

function ElementClass(opts) {
  if (!(this instanceof ElementClass)) return new ElementClass(opts)
  var self = this
  if (!opts) opts = {}

  // similar doing instanceof HTMLElement but works in IE8
  if (opts.nodeType) opts = {el: opts}

  this.opts = opts
  this.el = opts.el || document.body
  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)
}

ElementClass.prototype.add = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return el.className = className
  var classes = el.className.split(' ')
  if (classes.indexOf(className) > -1) return classes
  classes.push(className)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.remove = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return
  var classes = el.className.split(' ')
  var idx = classes.indexOf(className)
  if (idx > -1) classes.splice(idx, 1)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.has = function(className) {
  var el = this.el
  if (!el) return
  var classes = el.className.split(' ')
  return classes.indexOf(className) > -1
}

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var alnum, ref;

  ref = require('../ref').ref;

  alnum = {
    '0': ref('0', 48),
    '1': ref('1', 49),
    '2': ref('2', 50),
    '3': ref('3', 51),
    '4': ref('4', 52),
    '5': ref('5', 53),
    '6': ref('6', 54),
    '7': ref('7', 55),
    '8': ref('8', 56),
    '9': ref('9', 57),
    a: ref('A', 65),
    b: ref('B', 66),
    c: ref('C', 67),
    d: ref('D', 68),
    e: ref('E', 69),
    f: ref('F', 70),
    g: ref('G', 71),
    h: ref('H', 72),
    i: ref('I', 73),
    j: ref('J', 74),
    k: ref('K', 75),
    l: ref('L', 76),
    m: ref('M', 77),
    n: ref('N', 78),
    o: ref('O', 79),
    p: ref('P', 80),
    q: ref('Q', 81),
    r: ref('R', 82),
    s: ref('S', 83),
    t: ref('T', 84),
    u: ref('U', 85),
    v: ref('V', 86),
    w: ref('W', 87),
    x: ref('X', 88),
    y: ref('Y', 89),
    z: ref('Z', 90)
  };

  module.exports = alnum;

}).call(this);

},{"../ref":10}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var arrow, ref;

  ref = require('../ref').ref;

  arrow = {
    left: ref('Left', 37),
    up: ref('Up', 38),
    right: ref('Right', 39),
    down: ref('Down', 40)
  };

  module.exports = arrow;

}).call(this);

},{"../ref":10}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var brand, ref;

  ref = require('../ref').ref;

  brand = {
    apple: ref('Apple &#8984;', 224),
    windows: {
      start: ref('Windows start', [91, 92]),
      menu: ref('Windows menu', 93)
    }
  };

  module.exports = brand;

}).call(this);

},{"../ref":10}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var punctuation, ref;

  ref = require('../ref').ref;

  punctuation = {
    colon: ref('Colon/Semicolon', [59, 186]),
    equal: ref('Equal/Plus', [61, 187]),
    comma: ref('Comma/Less Than', [44, 188]),
    hyphen: ref('Hyphen/Underscore', [45, 109, 189]),
    period: ref('Period/Greater Than', [46, 190]),
    tilde: ref('Tilde/Back Tick', [96, 192]),
    apostrophe: ref('Apostrophe/Quote', [39, 222]),
    slash: {
      forward: ref('Forward Slash/Question Mark', [47, 191]),
      backward: ref('Backward Slash/Pipe', 220)
    },
    brace: {
      square: {
        open: ref('Open Square/Curly Brace', 219),
        close: ref('Close Square/Curly Brace', 221)
      }
    }
  };

  punctuation.semicolon = punctuation.colon;

  punctuation.plus = punctuation.equal;

  punctuation.lessthan = punctuation.comma;

  punctuation.underscore = punctuation.hyphen;

  punctuation.greaterthan = punctuation.period;

  punctuation.question = punctuation.slash.forward;

  punctuation.backtick = punctuation.tilde;

  punctuation.pipe = punctuation.slash.backward;

  punctuation.quote = punctuation.apostrophe;

  punctuation.brace.curly = punctuation.brace.square;

  module.exports = punctuation;

}).call(this);

},{"../ref":10}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var ref, special;

  ref = require('../ref').ref;

  special = {
    backspace: ref('Backspace', 8),
    tab: ref('Tab', 9),
    enter: ref('Enter', 13),
    shift: ref('Shift', 16),
    ctrl: ref('Ctrl', 17),
    alt: ref('Alt', 18),
    caps: ref('Caps Lock', 20),
    esc: ref('Escape', 27),
    space: ref('Space', 32),
    num: ref('Num Lock', 144)
  };

  module.exports = special;

}).call(this);

},{"../ref":10}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var isRef, iterator, key,
    _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  isRef = require('./ref').isRef;

  key = {};

  key.code = {
    special: require('./code/special'),
    arrow: require('./code/arrow'),
    punctuation: require('./code/punctuation'),
    alnum: require('./code/alnum'),
    brand: require('./code/brand')
  };

  key.get = function(pressed) {
    return iterator(key.code, pressed);
  };

  key.is = function(ref, pressed) {
    if (!isRef(ref)) {
      ref = iterator(ref, pressed);
    }
    if (isRef(ref)) {
      if (isRef(pressed)) {
        return pressed === ref;
      } else {
        return pressed === ref.code || __indexOf.call(ref.code, pressed) >= 0;
      }
    } else {
      return pressed === ref;
    }
  };

  iterator = function(context, pressed) {
    var i, out, ref;
    for (i in context) {
      if (!__hasProp.call(context, i)) continue;
      ref = context[i];
      if (isRef(ref)) {
        if (key.is(ref, pressed)) {
          return ref;
        }
      } else {
        out = iterator(ref, pressed);
        if (isRef(out)) {
          return out;
        }
      }
    }
  };

  if (typeof window !== 'undefined') {
    window.key = key;
  }

  module.exports = key;

}).call(this);

},{"./code/alnum":4,"./code/arrow":5,"./code/brand":6,"./code/punctuation":7,"./code/special":8,"./ref":10}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var Reference, assertRef, isRef, ref;

  Reference = (function() {

    function Reference(name, code) {
      this.name = name;
      this.code = code;
    }

    return Reference;

  })();

  ref = function(name, code) {
    return new Reference(name, code);
  };

  isRef = function(ref) {
    return ref instanceof Reference;
  };

  assertRef = function(ref) {
    if (!isRef(ref)) {
      throw new Error('Invalid reference');
    }
    return ref;
  };

  module.exports = {
    ref: ref,
    isRef: isRef,
    assertRef: assertRef
  };

}).call(this);

},{}],11:[function(require,module,exports){
var addDirtyProps = require('../add-dirty-props');
var util = require('../util');
var noop = require('../no-op');
var passThrough = require('../pass-through');
var debounce = require('../debounce');

module.exports = function(_grid, name, lengthName, defaultSize) {
    var grid = _grid;

    var descriptors = [];
    var numFixed = 0;
    var numHeaders = 0;
    var makeDirtyClean = require('../dirty-clean');
    var dirtyClean = makeDirtyClean(grid);
    var builderDirtyClean = makeDirtyClean(grid);
    var selected = [];


    function setDescriptorsDirty(eventOptional) {
        var event = eventOptional || {};
        event.type = 'grid-' + name + '-change';
        grid.eventLoop.fire(event);
        dirtyClean.setDirty();
        builderDirtyClean.setDirty();
    }

    var fireSelectionChange = debounce(function() {
        grid.eventLoop.fire('grid-' + name + '-selection-change');
    }, 1);

    function updateDescriptorIndices() {
        var oldSelected = selected;
        selected = [];
        descriptors.forEach(function(descriptor, i) {
            descriptor.index = i;
            if (descriptor.selected) {
                selected.push(i);
            }
        });
        if (selected.length !== oldSelected.length) {
            fireSelectionChange();
        }
        selected.sort();
        oldSelected.sort();
        var change = oldSelected.some(function(idx, i) {
            return idx !== selected[i];
        });
        if (change) {
            fireSelectionChange();
        }
    }

    var api = {
        areBuildersDirty: builderDirtyClean.isDirty,
        isDirty: dirtyClean.isDirty,
        defaultSize: defaultSize,
        add: function(toAdd) {
            if (!toAdd) {
                return;
            }

            if (!util.isArray(toAdd)) {
                toAdd = [toAdd];
            }
            toAdd.forEach(function(descriptor) {
                if (descriptor.header) {
                    descriptors.splice(numHeaders, 0, descriptor);
                    numFixed++;
                    numHeaders++;
                } else {
                    // if the column is fixed and the last one added is fixed (we only allow fixed at the beginning for now)
                    if (descriptor.fixed) {
                        if (!descriptors.length || descriptors[descriptors.length - 1].fixed) {
                            numFixed++;
                        } else {
                            throw 'Cannot add a fixed column after an unfixed one';
                        }
                    }
                    descriptors.push(descriptor);
                }
            });
            updateDescriptorIndices();
            setDescriptorsDirty({
                action: 'add',
                descriptors: toAdd
            });
        },
        addHeaders: function(toAdd) {
            if (!toAdd) {
                return;
            }

            if (!util.isArray(toAdd)) {
                toAdd = [toAdd];
            }
            toAdd.forEach(function(header) {
                header.header = true;
            });
            api.add(toAdd);
        },
        header: function(index) {
            return descriptors[index];
        },
        get: function(index) {
            return descriptors[index];
        },
        length: function(includeHeaders) {
            var subtract = includeHeaders ? 0 : numHeaders;
            return descriptors.length - subtract;
        },
        remove: function(descriptor, dontUpdateIndex) {
            var index = descriptors.indexOf(descriptor);
            if (index !== -1) {
                descriptors.splice(index, 1);
                if (descriptor.header) {
                    numFixed--;
                    numHeaders--;
                } else if (descriptor.fixed) {
                    numFixed--;
                }
            }
            if (!dontUpdateIndex) {
                updateDescriptorIndices();
                setDescriptorsDirty({
                    action: 'remove',
                    descriptors: [descriptor]
                });
            }
        },
        clear: function(includeHeaders) {
            var removed;
            if (includeHeaders) {
                removed = descriptors;
                descriptors = [];
                numFixed = 0;
                numHeaders = 0;
            } else {
                removed = descriptors.slice(numHeaders);
                descriptors = descriptors.slice(0, numHeaders);
                numFixed = numHeaders;
            }
            updateDescriptorIndices();
            if (removed && removed.length) {
                setDescriptorsDirty({
                    action: 'remove',
                    descriptors: removed
                });
            }
        },
        move: function(fromIndexes, target, after) {
            if (!util.isArray(fromIndexes)) {
                fromIndexes = [fromIndexes];
            }

            if (fromIndexes.length === 1) {
                // the single move case is easier and doesn't require the after hint
                var from = fromIndexes[0];
                descriptors.splice(target, 0, descriptors.splice(from, 1)[0]);
                setDescriptorsDirty({
                    action: 'move',
                    descriptors: [api.get(from), api.get(target)]
                });
            } else {
                while (fromIndexes.indexOf(target) !== -1 && target !== -1) {
                    target--;
                    after = true;
                }

                var toValue = descriptors[target];
                var removed = fromIndexes.sort(function compareNumbers(a, b) {
                    return b - a;
                }).map(function(fromIndex) {
                    var removedDescriptors = descriptors.splice(fromIndex, 1);
                    return removedDescriptors[0];

                });
                removed.reverse();
                var spliceArgs = [descriptors.indexOf(toValue) + (after ? 1 : 0), 0].concat(removed);
                descriptors.splice.apply(descriptors, spliceArgs);
                updateDescriptorIndices();
                setDescriptorsDirty({
                    action: 'move',
                    descriptors: removed.concat(toValue)
                });
            }
        },
        numHeaders: function() {
            return numHeaders;
        },
        numFixed: function(excludeHeaders) {
            return numFixed - (excludeHeaders ? numHeaders : 0);
        },
        toVirtual: function(dataIndex) {
            return dataIndex + api.numHeaders();
        },
        toData: function(virtualIndex) {
            return virtualIndex - api.numHeaders();
        },

        select: function(indexes, dontFire) {
            if (!util.isArray(indexes)) {
                indexes = [indexes];
            }
            var changes = indexes.filter(function(idx) {
                var hasDescriptor = !!api[name](idx);
                if (!hasDescriptor) {
                    console.warn('Tried to select index that had no descriptor', idx);
                }
                return hasDescriptor;
            }).map(function(idx) {
                var descriptor = api[name](idx);
                if (!descriptor.selected) {
                    descriptor.selected = true;
                    selected.push(idx);
                    return idx;
                }
            });
            if (changes.length && !dontFire) {
                fireSelectionChange();
            }
        },
        deselect: function(indexes, dontFire) {
            if (!util.isArray(indexes)) {
                indexes = [indexes];
            }
            var changes = indexes.filter(function(idx) {
                var hasDescriptor = !!api[name](idx);
                if (!hasDescriptor) {
                    console.warn('Tried to deselect index that had no descriptor', idx);
                }
                return hasDescriptor;
            }).map(function(idx) {
                var descriptor = api[name](idx);
                if (descriptor.selected) {
                    descriptor.selected = false;
                    selected.splice(selected.indexOf(idx), 1);
                    return idx;
                }
            });
            if (changes.length && !dontFire) {
                fireSelectionChange();
            }
        },
        toggleSelect: function(index) {
            var descriptor = api[name](index);
            if (descriptor.selected) {
                api.deselect(index);
            } else {
                api.select(index);
            }
        },
        clearSelected: function() {
            // have to make a copy or we are iterating the same array we're removing from yikes.
            return api.deselect(api.getSelected().slice(0));
        },
        getSelected: function() {
            return selected;
        },
        allSelected: function() {
            return api.getSelected().length === api.length();
        },
        create: function(builder) {
            var descriptor = {};
            var fixed = false;
            Object.defineProperty(descriptor, 'fixed', {
                enumerable: true,
                get: function() {
                    return descriptor.header || fixed;
                },
                set: function(_fixed) {
                    fixed = _fixed;
                }
            });
            var expanded = false;
            var expandedClass;
            Object.defineProperty(descriptor, 'expanded', {
                get: function() {
                    return expanded;
                },
                set: function(exp) {
                    if (!descriptor.children) {
                        return;
                    }
                    expanded = exp;
                    // we never look for changes to the children, if you need to change it, remove and add the row again
                    if (expanded) {
                        var spliceArgs = [descriptor.index + 1, 0].concat(descriptor.children)
                        descriptors.splice.apply(descriptors, spliceArgs);
                        updateDescriptorIndices();
                        setDescriptorsDirty({
                            action: 'add',
                            descriptors: descriptor.children
                        });
                        var top = name === 'row' ? descriptor.index : 0;
                        var left = name === 'col' ? descriptor.index : 0;
                        var height = name === 'row' ? 1 : Infinity;
                        var width = name === 'col' ? 1 : Infinity;
                        expandedClass = grid.cellClasses.create(top, left, 'grid-expanded', height, width, 'virtual');
                        grid.cellClasses.add(expandedClass);

                    } else {
                        descriptors.splice(descriptor.index + 1, descriptor.children.length);
                        updateDescriptorIndices();
                        setDescriptorsDirty({
                            action: 'remove',
                            descriptors: [descriptor.children]
                        });
                        if (expandedClass) {
                            grid.cellClasses.remove(expandedClass);
                        }
                    }
                }
            });

            addDirtyProps(descriptor, ['builder'], [builderDirtyClean]);
            descriptor.builder = builder;

            return addDirtyProps(descriptor, [{
                name: lengthName,
                onDirty: function() {
                    setDescriptorsDirty({
                        action: 'size',
                        descriptors: [descriptor]
                    });
                }
            }, {
                name: 'hidden',
                onDirty: function() {
                    setDescriptorsDirty({
                        action: 'hide',
                        descriptors: [descriptor]
                    });
                }
            }], [dirtyClean]);
        },
        createBuilder: function(render, update) {
            return {
                render: render || noop,
                update: update || passThrough
            };
        }

    };

    // basically height or width
    api[lengthName] = function(index) {
        var descriptor = descriptors[index];
        if (!descriptor) {
            return NaN;
        }


        if (descriptor.hidden) {
            return 0;
        }

        return descriptor[lengthName] || api.defaultSize;
    };

    // row or col get
    api[name] = function(index) {
        return descriptors[index + numHeaders];
    };

    return api;
};
},{"../add-dirty-props":12,"../debounce":25,"../dirty-clean":27,"../no-op":33,"../pass-through":34,"../util":42}],12:[function(require,module,exports){
module.exports = function(obj, props, dirtyCleans) {
    props.forEach(function(prop) {
        var val;
        var name = prop.name || prop;
        Object.defineProperty(obj, name, {
            enumerable: true,
            get: function() {
                return val;
            },
            set: function(_val) {
                var oldVal = val;
                var isChanged = _val !== oldVal
                if (isChanged && prop.preDirty) {
                    prop.preDirty();
                }
                val = _val;

                if (isChanged) {
                    dirtyCleans.forEach(function(dirtyClean) {
                        dirtyClean.setDirty();
                    });
                    if (prop.onDirty) {
                        prop.onDirty(_val, oldVal);
                    }
                }
            }
        });
    });
    return obj;
};
},{}],13:[function(require,module,exports){
module.exports = angular.module('grid-builder', [])
    .factory('GridBuilderSrvc', function($compile) {
        var GridBuilderSrvc = {};

        GridBuilderSrvc.destroy = function(elem) {
            if (elem) {
                var $prevElem = angular.element(elem);
                //if this thing doesn't actually have scope we will be destroying an inherited scope which is baaaaad
                if (!$prevElem.data('$scope')) {
                    return;
                }
                var $previousScope = $prevElem.scope();
                if ($previousScope) {
                    $previousScope.$destroy();
                }
                $prevElem.remove();
            }
        }

        GridBuilderSrvc.render = function($scope, tpl, initScopeFn) {
            var scope = $scope.$new();
            if (initScopeFn) {
                initScopeFn(scope);
            }
            var $elem = $compile(tpl)(scope);

            $elem.on('grid-rendered-elem-destroy', function() {
                GridBuilderSrvc.destroy($elem);
            });
            return $elem[0];
        };

        return GridBuilderSrvc;
    });
},{}],14:[function(require,module,exports){
module.exports = angular.module('grid-decorator', [])
    .factory('GridDecoratorSrvc', function($compile) {
        var GridDecoratorSrvc = {
            render: function(opts) {
                var compiled = $compile(opts.template)(opts.$scope);
                opts.$scope.$apply();

                // this absolutely has to happend after apply or the binding is to the wrong element (in fact anything you need to do has to happen after the apply)
                compiled.on('decorator-destroy', function() {
                    opts.$scope.$destroy();
                    // unbind in a timeout to allow any other listeners to fire first
                    setTimeout(function() {
                        compiled.remove();
                        compiled.off('decorator-destroy');
                    }, 1);
                });
                if (opts.events) {
                    compiled[0].style.pointerEvents = 'all';
                }
                return compiled[0];
            },
            headerDecorators: function(grid, model) {
                var origAnnotate = model.annotateDecorator;
                model.annotateDecorator = function(dec) {
                    dec.render = function() {
                        return GridDecoratorSrvc.render(dec.renderOpts);
                    };
                    if (origAnnotate) {
                        origAnnotate(dec);
                    }
                };

                require('../header-decorators')(grid, model);
            }
        };
        return GridDecoratorSrvc
    })

;
},{"../header-decorators":29}],15:[function(require,module,exports){
var positionRange = require('../position-range');
var makeDirtyClean = require('../dirty-clean');
var addDirtyProps = require('../add-dirty-props');

module.exports = function(_grid) {
    var grid = _grid;

    var dirtyClean = makeDirtyClean(grid);
    var descriptors = [];
    var cachedClassMatrix = [];

    var api = {
        add: function(descriptor) {
            descriptors.push(descriptor);
            addOrRemoveCachedClass(descriptor);
            dirtyClean.setDirty();
        },
        remove: function(descriptor) {
            var index = descriptors.indexOf(descriptor);
            if (index !== -1) {
                descriptors.splice(index, 1);
                addOrRemoveCachedClass(descriptor, true);
                dirtyClean.setDirty();
            }
        },
        getAll: function() {
            return descriptors.slice(0);
        },
        getCachedClasses: function(vRow, vCol) {
            return cachedClassMatrix[vRow] && cachedClassMatrix[vRow][vCol] || [];
        },
        create: function(top, left, className, height, width, space) {
            var thisDirtyClean = makeDirtyClean(grid);
            var descriptor = {};
            // mixins

            function classPreDirty() {
                addOrRemoveCachedClass(descriptor, true);
            }

            function classOnDirty() {
                addOrRemoveCachedClass(descriptor);
            }

            positionRange(descriptor, thisDirtyClean, dirtyClean, {
                preDirty: classPreDirty,
                onDirty: classOnDirty
            });
            addDirtyProps(descriptor, [{
                name: 'class',
                preDirty: classPreDirty,
                onDirty: classOnDirty
            }], [thisDirtyClean, dirtyClean]);

            // all of these are optional
            descriptor.top = top;
            descriptor.left = left;
            // default to single cell ranges
            descriptor.height = height || 1;
            descriptor.width = width || 1;
            descriptor.class = className;
            descriptor.space = space || descriptor.space;
            return descriptor;
        },
        isDirty: dirtyClean.isDirty
    };

    function regnerateCache() {
        cachedClassMatrix = [];
        api.getAll().forEach(function(descriptor) {
            addOrRemoveCachedClass(descriptor);
        })
    }

    grid.eventLoop.bind('grid-row-change', regnerateCache);
    grid.eventLoop.bind('grid-col-change', regnerateCache);

    function addOrRemoveCachedClass(descriptor, isRemove) {
        for (var r = descriptor.top; r < Math.min(descriptor.top + descriptor.height, grid.rowModel.length(true)); r++) {
            for (var c = descriptor.left; c < Math.min(descriptor.left + descriptor.width, grid.colModel.length(true)); c++) {
                var vRow = grid[descriptor.space].row.toVirtual(r);
                var vCol = grid[descriptor.space].col.toVirtual(c);
                var cols = cachedClassMatrix[vRow];
                if (!cols) {
                    cols = cachedClassMatrix[vRow] = [];
                }
                var cellClasses = cols[vCol];
                if (!cellClasses) {
                    if (!isRemove) {
                        cols[vCol] = [descriptor.class];
                    }
                    continue;
                }

                if (!isRemove) {
                    if (cellClasses.indexOf(descriptor.class) === -1) {
                        cellClasses.push(descriptor.class);
                    }
                } else {
                    var index = cellClasses.indexOf(descriptor.class);
                    if (index !== -1) {
                        cellClasses.splice(index, 1);
                    }
                }
            }
        }
    }


    return api;
};
},{"../add-dirty-props":12,"../dirty-clean":27,"../position-range":36}],16:[function(require,module,exports){
var customEvent = require('../custom-event');

var PROPS_TO_COPY_FROM_MOUSE_EVENTS = ['clientX', 'clientY', 'gridX', 'gridY', 'layerX', 'layerY', 'row', 'col', 'realRow', 'realCol'];


module.exports = function(_grid) {
    var grid = _grid;

    var model = {};

    var scrollInterval;

    model._annotateEvent = function annotateEvent(e) {
        /*eslint-disable no-fallthrough*/
        switch (e.type) {
            case 'click':
            case 'dblclick':
            case 'mousedown':
            case 'mousemove':
            case 'mouseup':
                model._annotateEventInternal(e);
                break;
        }
        /*eslint-enable no-fallthrough*/
    };

    model._annotateEventFromViewCoords = function(e, viewRow, viewCol) {
        e.realRow = viewRow;
        e.realCol = viewCol;
        e.virtualRow = grid.view.row.toVirtual(e.realRow);
        e.virtualCol = grid.view.col.toVirtual(e.realCol);
        e.row = grid.virtual.row.toData(e.virtualRow);
        e.col = grid.virtual.col.toData(e.virtualCol);
        return e;
    };

    model._annotateEventInternal = function(e) {
        var y = grid.viewPort.toGridY(e.clientY);
        var x = grid.viewPort.toGridX(e.clientX);
        var viewRow = grid.viewPort.getRowByTop(y);
        var viewCol = grid.viewPort.getColByLeft(x);
        model._annotateEventFromViewCoords(e, viewRow, viewCol);
        e.gridX = x;
        e.gridY = y;
    };

    var lastMoveRow;
    var lastMoveCol;
    grid.eventLoop.addInterceptor(function(e) {
        model._annotateEvent(e);
        if (e.type === 'mousedown') {
            if (e.currentTarget === grid.container) {
                setupDragEventForMouseDown(e);
            }
        } else if (e.type === 'mousemove') {
            if (e.row !== lastMoveRow || e.col !== lastMoveCol) {
                createAndFireCustomMouseEvent('grid-cell-mouse-move', e);
                lastMoveRow = e.row;
                lastMoveCol = e.col;
            }
        }
    });

    function calculateColScrollDiff(e) {
        var colDiff = 0;
        if (e.clientX > (grid.container && grid.container.getBoundingClientRect().right || window.innerWidth)) {
            colDiff = 1;
        } else if (grid.viewPort.toGridX(e.clientX) < grid.virtualPixelCellModel.fixedWidth()) {
            colDiff = -1;
        }
        return colDiff;
    }

    function calculateRowScrollDiff(e) {
        var rowDiff = 0;
        if (e.clientY > (grid.container && grid.container.getBoundingClientRect().bottom || window.innerHeight)) {
            rowDiff = 1;
        } else if (grid.viewPort.toGridY(e.clientY) < grid.virtualPixelCellModel.fixedHeight()) {
            rowDiff = -1;
        }
        return rowDiff;
    }

    function setupDragEventForMouseDown(downEvent) {
        var lastDragRow = downEvent.row;
        var lastDragCol = downEvent.col;
        var dragStarted = false;
        var unbindAutoScrollDrag;
        var lastX = downEvent.clientX;
        var lastY = downEvent.clientY;
        var unbindMove = grid.eventLoop.bind('mousemove', window, function(e) {


            if (dragStarted && !e.which) {
                // got a move event without mouse down which means we somehow missed the mouseup
                console.log('mousemove unbind, how on earth do these happen?');
                handleMouseUp(e);
                return;
            }

            if (!dragStarted) {
                if (lastX === e.clientX && lastY === e.clientY) {
                    console.error('Got a mouse move event with ', e.clientX, ',', e.clientY, ' when the last position was ', lastX, ',', lastY);
                }
                createAndFireCustomMouseEvent('grid-drag-start', downEvent, function annotateDragStart(dragStart) {
                    var onlyFixedRows = !calculateRowScrollDiff(e);
                    var onlyFixedCols = !calculateColScrollDiff(e);
                    dragStart.enableAutoScroll = function() {
                        if (unbindAutoScrollDrag) {
                            unbindAutoScrollDrag();
                        }
                        unbindAutoScrollDrag = grid.eventLoop.bind('grid-drag', function(e) {
                            // if it gets here then we will try to auto scroll
                            var newRowDiff = calculateRowScrollDiff(e);
                            onlyFixedRows = !newRowDiff;
                            var rowDiff = onlyFixedRows ? 0 : newRowDiff;


                            var newColDiff = calculateColScrollDiff;
                            onlyFixedCols = !newColDiff;
                            var colDiff = onlyFixedCols ? 0 : newColDiff(e);

                            clearInterval(scrollInterval);
                            if (rowDiff || colDiff) {
                                scrollInterval = grid.interval(function() {
                                    grid.cellScrollModel.scrollTo(grid.cellScrollModel.row + rowDiff, grid.cellScrollModel.col + colDiff);
                                }, 100);
                            }

                        });
                    };
                });
                dragStarted = true;
            }

            createAndFireCustomMouseEvent('grid-drag', e);

            if (e.row !== lastDragRow || e.col !== lastDragCol) {
                createAndFireCustomMouseEvent('grid-cell-drag', e);

                lastDragRow = e.row;
                lastDragCol = e.col;
            }

        });

        var unbindUp = grid.eventLoop.bind('mouseup', window, handleMouseUp);

        function handleMouseUp(e) {
            clearInterval(scrollInterval);
            unbindMove();
            unbindUp();
            if (unbindAutoScrollDrag) {
                unbindAutoScrollDrag();
            }

            var dragEnd = createCustomEventFromMouseEvent('grid-drag-end', e);

            // row, col, x, and y should inherit
            grid.eventLoop.fire(dragEnd);
        }
    }

    function createCustomEventFromMouseEvent(type, e) {
        var event = customEvent(type, true, true);
        PROPS_TO_COPY_FROM_MOUSE_EVENTS.forEach(function(prop) {
            event[prop] = e[prop];
        });
        event.originalEvent = e;
        return event;
    }

    function createAndFireCustomMouseEvent(type, e, annotateEvent) {
        var drag = createCustomEventFromMouseEvent(type, e);
        if (annotateEvent) {
            drag = annotateEvent(drag) || drag;
        }
        if (e.target) {
            e.target.dispatchEvent(drag);
        } else {
            grid.eventLoop.fire(drag);
        }
        return drag;
    }

    return model;
};
},{"../custom-event":24}],17:[function(require,module,exports){
var util = require('../util');

module.exports = function(_grid) {
    var grid = _grid;
    var dirtyClean = require('../dirty-clean')(grid);


    var row;
    var model = {
        col: 0
    };
    Object.defineProperty(model, 'row', {
        enumerable: true,
        get: function() {
            return row;
        },
        set: function(r) {
            row = r;
        }
    });
    model.row = 0;

    model.isDirty = dirtyClean.isDirty;

    grid.eventLoop.bind('grid-row-change', function(e) {
        switch (e.action) {
            case 'remove':
                model.scrollTo(0, model.col);
                break;
        }
    });

    model.scrollTo = function(r, c, dontFire, fromPixelModel) {
        if (isNaN(r) || isNaN(c)) {
            return;
        }
        var maxRow = (grid.rowModel.length() || 1) - 1;
        var maxCol = (grid.colModel.length() || 1) - 1;
        var lastRow = model.row;
        var lastCol = model.col;
        model.row = util.clamp(r, 0, maxRow);
        model.col = util.clamp(c, 0, maxCol);
        if (lastRow !== model.row || lastCol !== model.col) {
            dirtyClean.setDirty();

            if (!dontFire) {
                grid.eventLoop.fire('grid-cell-scroll');
            }

            if (!fromPixelModel) {
                var top = grid.virtualPixelCellModel.height(grid.rowModel.numFixed(), model.row + grid.rowModel.numFixed() - 1);
                var left = grid.virtualPixelCellModel.width(grid.colModel.numFixed(), model.col + grid.colModel.numFixed() - 1);
                grid.pixelScrollModel.scrollTo(top, left, true);
            }
        }
    };

    function convertVirtualToScroll(virtualCoord, rowOrCol) {
        return virtualCoord - grid[rowOrCol + 'Model'].numFixed();
    }

    function getScrollToRowOrCol(virtualCoord, rowOrCol, heightWidth) {
        var currentScroll = model[rowOrCol];
        var scrollTo = currentScroll;
        if (grid.viewPort[rowOrCol + 'IsInView'](virtualCoord)) {
            return scrollTo;
        }

        var targetScroll = convertVirtualToScroll(virtualCoord, rowOrCol);
        if (targetScroll < currentScroll) {
            scrollTo = targetScroll;
        } else if (targetScroll > currentScroll) {

            var lengthToCell = grid.virtualPixelCellModel[heightWidth](0, virtualCoord);
            var numFixed = grid[rowOrCol + 'Model'].numFixed();
            scrollTo = 0;
            for (var i = numFixed; i < virtualCoord; i++) {
                lengthToCell -= grid.virtualPixelCellModel[heightWidth](i);
                scrollTo = i - (numFixed - 1);
                if (lengthToCell <= grid.viewPort[heightWidth]) {
                    break;
                }
            }
        }

        return scrollTo;
    }

    //for now assumes data space
    model.scrollIntoView = function(dataRow, dataCol) {
        dataRow = grid.virtual.row.clamp(grid.data.row.toVirtual(dataRow));
        dataCol = grid.virtual.col.clamp(grid.data.col.toVirtual(dataCol));
        var newRow = getScrollToRowOrCol(dataRow, 'row', 'height');
        var newCol = getScrollToRowOrCol(dataCol, 'col', 'width');
        model.scrollTo(newRow, newCol);
    };


    return model;
};
},{"../dirty-clean":27,"../util":42}],18:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = require('../abstract-row-col-model')(grid, 'col', 'width', 100);

    return api;
};
},{"../abstract-row-col-model":11}],19:[function(require,module,exports){
var elementClass = require('element-class');
var util = require('../util');
var ctrlOrCmd = require('../ctrl-or-cmd');
var key = require('key');

module.exports = function(_grid) {
    var grid = _grid;

    var api = {
        annotateDecorator: makeReorderDecorator
    };

    function makeReorderDecorator(headerDecorator) {

        var wasSelectedAtMousedown = false;
        headerDecorator._onMousedown = function(e) {
            wasSelectedAtMousedown = grid.data.col.get(e.col).selected;
            if (wasSelectedAtMousedown && !ctrlOrCmd(e)) {
                grid.eventLoop.stopBubbling(e);
            }
        }


        headerDecorator._onDragStart = function(e) {

            if (e.realCol < grid.colModel.numFixed() || !wasSelectedAtMousedown) {
                return;
            }
            if (e.enableAutoScroll) {
                e.enableAutoScroll();
            }
            // we want to be the only draggers
            grid.eventLoop.stopBubbling(e);

            var startCol = headerDecorator.left;

            // create the target line
            api._targetCol = grid.decorators.create(0, undefined, Infinity, 1, 'cell', 'real');
            api._targetCol.postRender = function(div) {
                div.setAttribute('class', 'grid-reorder-target');
                api._targetCol._renderedElem = div;
            };
            grid.decorators.add(api._targetCol);

            // create a decorator for each selected col
            var selected = grid.colModel.getSelected();
            api._dragRects = selected.map(function(dataCol) {
                var viewCol = grid.data.col.toView(dataCol);
                var dragRect = grid.decorators.create(0, undefined, Infinity, undefined, 'px', 'real');
                dragRect.colOffset = e.gridX - api._decorators[viewCol].getDecoratorLeft();
                dragRect.postRender = function(div) {
                    div.setAttribute('class', 'grid-drag-rect');
                };
                dragRect.width = grid.viewPort.getColWidth(viewCol);
                return dragRect;
            });

            grid.decorators.add(api._dragRects);

            headerDecorator._unbindKeyDown = grid.escapeStack && grid.escapeStack.addEscapeHandler(removeDecoratorsAndUnbind);

            headerDecorator._unbindDrag = grid.eventLoop.bind('grid-drag', function(e) {
                api._dragRects.forEach(function(dragRect) {
                    dragRect.left = util.clamp(e.gridX - dragRect.colOffset, grid.viewPort.getColLeft(grid.colModel.numFixed()), Infinity);
                });
                api._targetCol.left = util.clamp(e.realCol, grid.colModel.numFixed(), Infinity);
                api._targetCol.moveAfter = e.realCol > startCol;
                if (api._targetCol.moveAfter) {
                    elementClass(api._targetCol._renderedElem).add('right');
                } else {
                    elementClass(api._targetCol._renderedElem).remove('right');
                }


            });

            headerDecorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function() {
                var targetCol = api._targetCol.left;

                grid.colModel.move(selected.map(function(dataCol) {
                    return grid.data.col.toVirtual(dataCol);
                }), grid.viewPort.toVirtualCol(targetCol), api._targetCol.moveAfter);

                removeDecoratorsAndUnbind();
            });

            function removeDecoratorsAndUnbind() {
                var removedDecs = api._dragRects.concat(api._targetCol);
                grid.decorators.remove(removedDecs);
                headerDecorator._unbindDrag();
                headerDecorator._unbindDragEnd();
                headerDecorator._unbindKeyDown && headerDecorator._unbindKeyDown();
                return true; // for the escape stack
            }
        };

        headerDecorator.postRender = function(div) {
            div.setAttribute('class', 'grid-col-reorder');
            grid.eventLoop.bind('grid-drag-start', div, headerDecorator._onDragStart);
            grid.eventLoop.bind('mousedown', div, headerDecorator._onMousedown);
        };

        return headerDecorator;
    }

    require('../header-decorators')(grid, api);

    return api;
};
},{"../ctrl-or-cmd":23,"../header-decorators":29,"../util":42,"element-class":3,"key":9}],20:[function(require,module,exports){
var key = require('key');

module.exports = function(_grid) {
    var grid = _grid;

    var api = {
        annotateDecorator: annotateDecorator
    };

    function annotateDecorator(headerDecorator) {
        var col = headerDecorator.left;
        headerDecorator._dragLine = grid.decorators.create(0, undefined, Infinity, 1, 'px', 'real');

        headerDecorator._dragLine.postRender = function(div) {
            div.setAttribute('class', 'grid-drag-line');
        };

        headerDecorator._onMousedown = function(e) {
            //prevent mousedowns from getting to selection if they hit the dragline
            grid.eventLoop.stopBubbling(e);
        };

        headerDecorator._onDragStart = function(e) {

            grid.eventLoop.stopBubbling(e);

            grid.decorators.add(headerDecorator._dragLine);

            headerDecorator._unbindDrag = grid.eventLoop.bind('grid-drag', function(e) {
                var minX = headerDecorator.getDecoratorLeft() + 10;
                headerDecorator._dragLine.left = Math.max(e.gridX, minX);
            });

            headerDecorator._unbindKeyDown = grid.escapeStack && grid.escapeStack.addEscapeHandler(removeDecoratorsAndUnbind);

            headerDecorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function(e) {
                var newWidth = headerDecorator._dragLine.left - headerDecorator.getDecoratorLeft();
                grid.view.col.get(col).width = newWidth;
                grid.colModel.getSelected().forEach(function(dataIdx) {
                    grid.data.col.get(dataIdx).width = newWidth;
                });
                removeDecoratorsAndUnbind();
            });

            function removeDecoratorsAndUnbind() {
                grid.decorators.remove(headerDecorator._dragLine);
                headerDecorator._unbindDrag();
                headerDecorator._unbindDragEnd();
                headerDecorator._unbindKeyDown && headerDecorator._unbindKeyDown();
                return true; // for the escape stack
            }
        };

        headerDecorator.postRender = function(div) {
            div.style.transform = 'translateX(50%)';
            div.style.webkitTransform = 'translateX(50%)';

            div.style.removeProperty('left');
            div.setAttribute('class', 'col-resize');
            div.setAttribute('dts', 'grid_header_resize');

            grid.eventLoop.bind('grid-drag-start', div, headerDecorator._onDragStart);
            grid.eventLoop.bind('mousedown', div, headerDecorator._onMousedown);
        };
    }

    require('../header-decorators')(grid, api);

    return api;
};
},{"../header-decorators":29,"key":9}],21:[function(require,module,exports){
var tsv = require('../tsv');
var debounce = require('../debounce');

module.exports = function(_grid) {
    var grid = _grid;
    var model = {};

    function getCopyPasteRange() {
        var selectionRange = grid.navigationModel.selection;
        //valid selection range cannot go to -1
        if (selectionRange.top === -1) {
            selectionRange = {
                top: grid.navigationModel.focus.row,
                left: grid.navigationModel.focus.col,
                width: 1,
                height: 1
            };
        }
        return selectionRange;
    }

    grid.eventLoop.bind('copy', function(e) {
        if (!grid.focused) {
            if (e.target === grid.textarea) {
                e.preventDefault();
            }
            return;
        }
        // prepare for copy
        var copyTable = document.createElement('table');
        var tableBody = document.createElement('tbody');
        copyTable.appendChild(tableBody);
        var tsvData = [];
        var selectionRange = getCopyPasteRange();
        var gotNull = false;
        grid.data.iterate(selectionRange, function() {
            var row = document.createElement('tr');
            tableBody.appendChild(row);
            var array = [];
            tsvData.push(array);
            return {
                row: row,
                array: array
            };
        }, function(r, c, rowResult) {
            var data = grid.dataModel.getCopyData(r, c);

            // intentional == checks null or undefined
            if (data == null) {
                return gotNull = true; // this breaks the col loop
            }
            var td = document.createElement('td');
            td.innerHTML = data || ' ';
            rowResult.row.appendChild(td);
            rowResult.array.push(td.textContent);
        });
        if (!gotNull) {
            e.clipboardData.setData('text/plain', tsv.stringify(tsvData));
            e.clipboardData.setData('text/html', copyTable.outerHTML);
            e.preventDefault();
            setTimeout(function() {
                grid.eventLoop.fire('grid-copy');
            }, 1);
        }
    });

    grid.eventLoop.bind('paste', function(e) {
        if (!grid.focused) {
            return;
        }
        var selectionRange = getCopyPasteRange();
        if (!e.clipboardData || !e.clipboardData.getData) {
            console.warn('no clipboard data on paste event');
            return;
        }
        var pasteData = tsv.parse(e.clipboardData.getData('text/plain'));
        var pasteHtml = e.clipboardData.getData('text/html');
        e.preventDefault();

        setTimeout(function() {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = pasteHtml;
            if (tempDiv.querySelector('table')) {
                pasteData = [];
                [].forEach.call(tempDiv.querySelectorAll('tr'), function(tr) {
                    var row = [];
                    pasteData.push(row);
                    [].forEach.call(tr.querySelectorAll('td'), function(td) {
                        row.push(td.innerHTML);
                    });
                });
            }
            var dataChanges = [];
            var singlePasteValue;
            if (pasteData.length === 1 && pasteData[0].length === 1) {
                singlePasteValue = pasteData[0][0];
            }

            if (singlePasteValue) {
                // this will do nothing if no other selections as it will be an empty array
                var ranges = [selectionRange];
                ranges = ranges.concat(grid.navigationModel.otherSelections);
                ranges.forEach(function(range) {
                    grid.data.iterate(range, function(r, c) {
                        var pasteValue = singlePasteValue;
                        dataChanges.push({
                            row: r,
                            col: c,
                            data: pasteValue && pasteValue.trim(),
                            paste: true
                        });
                    });
                });
            } else {
                var top = selectionRange.top;
                var left = selectionRange.left;

                pasteData.forEach(function(row, r) {
                    row.forEach(function(pasteValue, c) {
                        if (pasteValue == undefined) {
                            return;
                        }
                        dataChanges.push({
                            row: r + top,
                            col: c + left,
                            data: pasteValue && pasteValue.trim(),
                            paste: true
                        });
                    });
                });
                var newSelection = {
                    top: top,
                    left: left,
                    height: pasteData.length,
                    width: pasteData[0].length
                };

                grid.navigationModel.clearSelection()
                grid.navigationModel.setSelection(newSelection)
            }


            grid.dataModel.set(dataChanges);
        }, 1);
    });

    var maybeSelectText = debounce(function maybeSelectTextInner() {
        if ((!model.isSelectionDisabled || !model.isSelectionDisabled()) && grid.focused) {
            grid.textarea.value = grid.dataModel.get(grid.navigationModel.focus.row, grid.navigationModel.focus.col).formatted || '.';
            grid.textarea.select();
        }
    }, 1)

    model._maybeSelectText = maybeSelectText;

    grid.eventLoop.bind('keyup', function(e) {
        maybeSelectText();
    });
    grid.eventLoop.bind('grid-focus', function(e) {
        maybeSelectText();
    });
    grid.eventLoop.bind('mousedown', function(e) {
        if (e.target !== grid.textarea) {
            return;
        }
        maybeSelectText();
    });
    return model;
};
},{"../debounce":25,"../tsv":41}],22:[function(require,module,exports){
var elementClass = require('element-class');
var dirtyClean = require('../dirty-clean');
var util = require('../util');
var rangeUtil = require('../range-util');
var passThrough = require('../pass-through');
var capitalize = require('capitalize');

module.exports = function(opts) {
    function GridMarker() {

    }
    var grid = new GridMarker();

    // the order here matters because some of these depend on each other
    grid.eventLoop = require('../event-loop')(grid);
    grid.decorators = require('../decorators')(grid);
    grid.cellClasses = require('../cell-classes')(grid);
    grid.rowModel = require('../row-model')(grid);
    grid.colModel = require('../col-model')(grid);
    grid.dataModel = require('../simple-data-model')(grid);
    grid.virtualPixelCellModel = require('../virtual-pixel-cell-model')(grid);
    grid.cellScrollModel = require('../cell-scroll-model')(grid);
    grid.cellMouseModel = require('../cell-mouse-model')(grid);

    grid.viewPort = require('../view-port')(grid);

    addUtilsToCore(); // this has to happen here for things not to break, view layer will add cell classes and that cache requires the utils


    grid.viewLayer = require('../view-layer')(grid);

    // things with logic that also register decorators (slightly less core than the other models)
    grid.navigationModel = require('../navigation-model')(grid);
    grid.pixelScrollModel = require('../pixel-scroll-model')(grid);
    grid.colResize = require('../col-resize')(grid);
    if (!(opts && opts.col && opts.col.disableReorder)) {
        grid.colReorder = require('../col-reorder')(grid);
    }
    grid.showHiddenCols = require('../show-hidden-cols')(grid);
    grid.copyPaste = require('../copy-paste')(grid);

    var drawRequested = false;
    grid.requestDraw = function() {
        if (!grid.eventLoop.isRunning) {
            grid.viewLayer.draw();
        } else {
            drawRequested = true;
        }
    };

    grid.eventLoop.bind('grid-draw', function() {
        drawRequested = false;
    });

    grid.eventLoop.addExitListener(function() {
        if (drawRequested) {
            grid.viewLayer.draw();
        }
    });

    function setupTextareaForContainer(textarea, container) {
        textarea.addEventListener('focus', function() {
            if (container) {
                elementClass(container).add('focus');
            }
            textarea.select();
            grid.focused = true;
            grid.eventLoop.fire('grid-focus');
        });

        textarea.addEventListener('blur', function() {
            if (container) {
                elementClass(container).remove('focus');
            }
            grid.focused = false;
            grid.eventLoop.fire('grid-blur');
        });

        var widthResetTimeout;
        grid.eventLoop.addInterceptor(function(e) {
            if (e.type !== 'mousedown' || e.button !== 2) {
                return;
            }
            textarea.style.width = '100%';
            textarea.style.height = '100%';
            textarea.style.zIndex = 1;
            clearTimeout(widthResetTimeout);
            widthResetTimeout = setTimeout(function() {
                textarea.style.zIndex = 0;
                textarea.style.width = '0px';
                textarea.style.height = '1px';
            }, 1);
        });

        container.appendChild(textarea);
        if (!container.getAttribute('tabIndex')) {
            container.tabIndex = -1;
        }
        container.addEventListener('focus', function() {
            if (textarea) {
                textarea.focus();
            }
        });
    }


    function createFocusTextArea() {
        var textarea = document.createElement('textarea');
        textarea.setAttribute('dts', 'grid-textarea');
        util.position(textarea, 0, 0);
        textarea.style.width = '0px';
        textarea.style.height = '1px';
        textarea.style.maxWidth = '100%';
        textarea.style.maxHeight = '100%';
        textarea.style.zIndex = 0;
        textarea.style.overflow = 'hidden';

        textarea.style.background = 'transparent';
        textarea.style.color = 'transparent';
        textarea.style.border = 'none';
        textarea.style.boxShadow = 'none';
        textarea.style.cursor = 'default';
        textarea.classList.add('grid-textarea');
        textarea.setAttribute('ondragstart', 'return false;');

        return textarea;
    }

    function addUtilsToCore() {
        function iterateRange() {
            // expects to be called with the space as its this
            var args = rangeUtil.getArgs(arguments);
            var range = args.range;
            var rowFn = args.rowFn;
            var cellFn = args.cellFn;
            var rowResult;
            rowloop: for (var r = range.top; r < range.top + range.height; r = this.row.next(r)) {
                rowResult = undefined;
                if (rowFn) {
                    rowResult = rowFn(r);
                }
                colloop: for (var c = range.left; c < range.left + range.width; c = this.col.next(c)) {
                    if (cellFn) {
                        var result = cellFn(r, c, rowResult);
                        if (result === false) {
                            break rowloop;
                        } else if (result === true) {
                            break colloop;
                        }
                    }
                }
            }
        }

        function iterateWhileHidden(step, start) {
            step = step || 1;
            for (var i = start + step; i < this.count() && i >= 0; i += step) {
                if (!this.get(i).hidden) {
                    return i;
                }
            }
        }

        function addToDimension(dim, spaceName, getter) {
            //convert whatever space to virtual and use the row or col virtual getter
            dim.get = function(idx) {
                return getter(this.toVirtual(idx));
            }.bind(dim);
            dim.next = iterateWhileHidden.bind(dim, 1);
            dim.prev = iterateWhileHidden.bind(dim, -1);
            dim.clamp = function(idx) {
                return util.clamp(idx, 0, this.count() - 1);
            }.bind(dim);
            dim.indexes = function() {
                var opts;
                opts = arguments[0];
                opts = opts || {};
                opts.from = opts.from || 0;
                var count = this.count();
                opts.to = opts.to + 1 || (opts.length && opts.length + opts.from) || count;
                var indexes = [];
                for (var idx = Math.max(opts.from, 0); idx < Math.min(opts.to, count); idx = opts.reverse ? this.prev(idx) : this.next(idx)) {
                    indexes.push(idx);
                }
                return indexes;
            };

            dim.iterate = function() {
                var opts;
                var fn;
                if (arguments.length === 2) {
                    opts = arguments[0];
                    fn = arguments[1];
                } else {
                    fn = arguments[0];
                }
                dim.indexes(opts).some(function(idx) {
                    return fn(idx);
                });
            };

            // have data to data be passthrough for example
            dim['to' + capitalize(spaceName)] = passThrough;

            return dim;
        }

        function addToSpace(spaceName) {
            var space = grid[spaceName];
            space.iterate = iterateRange.bind(space);
            addToDimension(space.col, spaceName, function(idx) {
                return grid.colModel.get(idx);
            });
            addToDimension(space.row, spaceName, function(idx) {
                return grid.rowModel.get(idx);
            });
            space.up = space.row.prev;
            space.down = space.row.next;
            space.left = space.col.prev;
            space.right = space.col.next;
        }


        grid.data = {
            col: {
                toVirtual: function(dataCol) {
                    return grid.colModel.toVirtual(dataCol);
                },
                toView: function(dataCol) {
                    return grid.virtual.col.toView(this.toVirtual(dataCol));
                },
                count: function() {
                    return grid.colModel.length();
                }
            },
            row: {
                toVirtual: function(dataRow) {
                    return grid.rowModel.toVirtual(dataRow);
                },
                toView: function(dataRow) {
                    return grid.virtual.row.toView(this.toVirtual(dataRow));
                },
                count: function() {
                    return grid.rowModel.length();
                }
            }
        };
        addToSpace('data');

        grid.virtual = {
            col: {
                toData: function(virtualCol) {
                    return grid.colModel.toData(virtualCol);
                },
                toView: function(virtualCol) {
                    return grid.viewPort.toRealCol(virtualCol);
                },
                count: function() {
                    return grid.colModel.length(true);
                }
            },
            row: {
                toData: function(virtualRow) {
                    return grid.rowModel.toData(virtualRow);
                },
                toView: function(virtualRow) {
                    return grid.viewPort.toRealRow(virtualRow);
                },
                count: function() {
                    return grid.rowModel.length(true);
                }
            }
        };
        addToSpace('virtual');

        grid.view = {
            col: {
                toData: function(viewCol) {
                    return grid.virtual.col.toData(this.toVirtual(viewCol));
                },
                toVirtual: function(viewCol) {
                    return grid.viewPort.toVirtualCol(viewCol);
                },
                count: function() {
                    return grid.viewPort.cols;
                }
            },
            row: {
                toData: function(viewRow) {
                    return grid.virtual.row.toData(this.toVirtual(viewRow));
                },
                toVirtual: function(viewRow) {
                    return grid.viewPort.toVirtualRow(viewRow);
                },
                count: function() {
                    return grid.viewPort.rows;
                }
            }
        };
        addToSpace('view');

        timeouts = [];
        grid.timeout = function() {
            var id = setTimeout.apply(window, arguments);
            timeouts.push(id);
            return id;
        };
        intervals = [];
        grid.interval = function() {
            var id = setInterval.apply(window, arguments);
            intervals.push(id);
            return id;
        };
    }

    var intervals;
    var timeouts;
    grid.eventLoop.bind('grid-destroy', function() {
        intervals.forEach(function(id) {
            clearInterval(id);
        });

        timeouts.forEach(function(id) {
            clearTimeout(id);
        });
    });

    grid.build = function(container) {
        grid.container = container;
        setupTextareaForContainer(grid.textarea, container);
        grid.viewPort.sizeToContainer(container);
        grid.viewLayer.build(container);
        grid.eventLoop.setContainer(container);
        container.style.overflow = 'hidden';
        // the container should never actually scroll, but the browser does automatically sometimes so let's reset it when that happens
        container.addEventListener('scroll', function() {
            container.scrollTop = 0;
            container.scrollLeft = 0;
        });
    };

    grid.makeDirtyClean = function() {
        return dirtyClean(grid);
    };

    grid.eventIsOnCells = function(e) {
        var target = e.target;
        return target && (target.classList &&
                (target.classList.contains('grid-col-reorder') ||
                    target.classList.contains('grid-cell')
                )) ||
            target === grid.textarea;
    }

    grid.textarea = createFocusTextArea();

    grid.destroy = function() {
        grid.eventLoop.fire('grid-destroy');
    };

    return grid;
};
},{"../cell-classes":15,"../cell-mouse-model":16,"../cell-scroll-model":17,"../col-model":18,"../col-reorder":19,"../col-resize":20,"../copy-paste":21,"../decorators":26,"../dirty-clean":27,"../event-loop":28,"../navigation-model":32,"../pass-through":34,"../pixel-scroll-model":35,"../range-util":37,"../row-model":38,"../show-hidden-cols":39,"../simple-data-model":40,"../util":42,"../view-layer":43,"../view-port":44,"../virtual-pixel-cell-model":45,"capitalize":2,"element-class":3}],23:[function(require,module,exports){
module.exports = function (e) {
    return (window.navigator.userAgent.match(/win/i) ? e.ctrlKey : e.metaKey)
};
},{}],24:[function(require,module,exports){
module.exports = function (name, bubbles, cancelable, detail) {
    var event = document.createEvent('CustomEvent');  // MUST be 'CustomEvent'
    event.initCustomEvent(name, bubbles, cancelable, detail);
    return event;
};
},{}],25:[function(require,module,exports){
module.exports = function(fn, delay) {
    var f = function debounced() {
        if (f.timeout) {
            clearTimeout(f.timeout);
            f.timeout = undefined;
        }
        if (!f.canceled) {
            f.timeout = setTimeout(fn, delay);
        }
        f.cancel = function() {
            clearTimeout(f.timeout);
            f.timeout = undefined;
            f.canceled = true;
        };
    };
    return f;
};
},{}],26:[function(require,module,exports){
var util = require('../util');
var makeDirtyClean = require('../dirty-clean');
var positionRange = require('../position-range');

module.exports = function (_grid) {
    var grid = _grid;

    var dirtyClean = makeDirtyClean(grid);

    var aliveDecorators = [];
    var deadDecorators = [];

    var decorators = {
        add: function (decorators) {
            if (!util.isArray(decorators)) {
                decorators = [decorators];
            }
            decorators.forEach(function (decorator) {
                aliveDecorators.push(decorator);
            });
            dirtyClean.setDirty();
        },
        remove: function (decorators) {
            if (!util.isArray(decorators)) {
                decorators = [decorators];
            }
            decorators.forEach(function (decorator) {
                var index = aliveDecorators.indexOf(decorator);
                if (index !== -1) {
                    aliveDecorators.splice(index, 1);
                    deadDecorators.push(decorator);
                    dirtyClean.setDirty();
                }
            });
        },
        getAlive: function () {
            return aliveDecorators.slice(0);
        },
        popAllDead: function () {
            var oldDead = deadDecorators;
            deadDecorators = [];
            return oldDead;
        },
        isDirty: dirtyClean.isDirty,
        create: function (t, l, h, w, u, s) {
            var decorator = {};
            var thisDirtyClean = makeDirtyClean(grid);

            //mixin the position range functionality
            positionRange(decorator, thisDirtyClean, dirtyClean);
            decorator.top = t;
            decorator.left = l;
            decorator.height = h;
            decorator.width = w;
            decorator.units = u || decorator.units;
            decorator.space = s || decorator.space;

            //they can override but we should have an empty default to prevent npes
            decorator.render = function () {
                var div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.top = '0px';
                div.style.left = '0px';
                div.style.bottom = '0px';
                div.style.right = '0px';
                if (decorator.postRender) {
                    decorator.postRender(div);
                }
                return div;
            };
            return decorator;

        }

    };


    return decorators;
};
},{"../dirty-clean":27,"../position-range":36,"../util":42}],27:[function(require,module,exports){
module.exports = function(_grid) {
    var grid = _grid;
    var dirty = true;

    grid.eventLoop.bind('grid-draw', function() {
        api.setClean();
    });


    var api = {
        isDirty: function() {
            return dirty;
        },
        isClean: function() {
            return !dirty;
        },
        setDirty: function() {
            dirty = true;
            // when things are initalizing sometimes this doesn't exist yet
            // we have to hope that at the end of initialization the grid will call request draw itself
            if (grid.requestDraw) {
                grid.requestDraw();
            }
        },
        setClean: function() {
            dirty = false;
        }
    };
    return api;
};
},{}],28:[function(require,module,exports){
var mousewheel = require('../mousewheel');
var util = require('../util');
var listeners = require('../listeners');

var EVENTS = ['click', 'mousedown', 'mouseup', 'mousemove', 'dblclick', 'keydown', 'keypress', 'keyup', 'copy', 'paste'];

var GRID_EVENTS = ['grid-drag-start', 'grid-drag', 'grid-cell-drag', 'grid-drag-end', 'grid-cell-mouse-move'];

var eventLoop = function(_grid) {
    var grid = _grid;
    var eloop = {
        isRunning: false
    };

    var handlersByName = {};
    var domUnbindFns = [];

    var unbindAll;

    eloop.setContainer = function(container) {
        var unbindMouseWheelFn = mousewheel.bind(container, mainLoop);

        EVENTS.forEach(function(name) {
            bindToDomElement(container, name, mainLoop);
        });

        GRID_EVENTS.forEach(function(name) {
            bindToDomElement(window, name, mainLoop);
        });

        unbindAll = function() {
            unbindMouseWheelFn();

            // have to copy the array since the unbind will actually remove itself from the array which modifies it mid iteration
            domUnbindFns.slice(0).forEach(function(unbind) {
                unbind();
            });

            Object.keys(handlersByName).forEach(function(key) {
                handlersByName[key] = [];
            });
        };
    };

    function getHandlers(name) {
        var handlers = handlersByName[name];
        if (!handlers) {
            handlers = handlersByName[name] = [];
        }
        return handlers;
    }

    function bindToDomElement(elem, name, listener) {
        elem.addEventListener(name, listener);
        var unbindFn = function() {
            elem.removeEventListener(name, listener);
            domUnbindFns.splice(domUnbindFns.indexOf(unbindFn), 1);
        };
        domUnbindFns.push(unbindFn);
        return unbindFn;
    }

    function getHandlerFromArgs(args) {
        var handler = args.filter(function(arg) {
            return typeof arg === 'function';
        })[0];
        return handler;
    }

    eloop.bind = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var name = args.filter(function(arg) {
            return typeof arg === 'string';
        })[0];
        var handler = getHandlerFromArgs(args);
        if (!handler || !name) {
            throw 'cannot bind without at least name and function';
        }


        var elem = args.filter(function(arg) {
            return util.isElement(arg) || arg === window || arg === document;
        })[0];

        if (!elem) {
            getHandlers(name).push(handler);
            return function() {
                var handlers = getHandlers(name);
                handlers.splice(handlers.indexOf(handler), 1);
            };
        } else {
            var listener = loopWith(handler);
            // make sure the elem can receive events
            if (elem.style) {
                elem.style.pointerEvents = 'auto';
            }
            return bindToDomElement(elem, name, listener);
        }
    };

    eloop.bindOnce = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var handler = getHandlerFromArgs(args);
        args.splice(args.indexOf(handler), 1, function bindOnceHandler(e) {
            unbind();
            handler(e);
        });
        var unbind = eloop.bind.apply(this, args);
        return unbind;
    }

    eloop.fire = function(event) {
        event = typeof event === 'string' ? {
            type: event
        } : event;
        mainLoop(event);
    };

    var interceptors = listeners();
    var exitListeners = listeners();

    eloop.addInterceptor = interceptors.addListener;
    eloop.addExitListener = exitListeners.addListener;

    function loopWith(fn) {
        return function(e) {
            loop(e, fn);
        };
    }

    var mainLoop = loopWith(function(e) {
        // have to copy the array because handlers can unbind themselves which modifies the array
        // we use some so that we can break out of the loop if need be
        getHandlers(e.type).slice(0).some(function(handler) {
            handler(e);
            if (e.gridStopBubbling) {
                return true;
            }
        });
    });

    function loop(e, bodyFn) {
        if (eloop.logTargets) {
            console.log('target', e.target, 'currentTarget', e.currentTarget);
        }
        var isOuterLoopRunning = eloop.isRunning;
        eloop.isRunning = true;
        interceptors.notify(e);
        if (!e.gridStopBubbling) {
            bodyFn(e);
        }

        if (!isOuterLoopRunning) {
            eloop.isRunning = false;
            exitListeners.notify(e);
        }
    }

    eloop.bind('grid-destroy', function() {
        unbindAll();
        eloop.destroyed = true;
    });

    eloop.stopBubbling = function(e) {
        e.gridStopBubbling = true;
        return e;
    };

    return eloop;
};


eventLoop.EVENTS = EVENTS;
eventLoop.GRID_EVENTS = GRID_EVENTS;
module.exports = eventLoop;
},{"../listeners":30,"../mousewheel":31,"../util":42}],29:[function(require,module,exports){
module.exports = function (_grid, model) {
    var grid = _grid;

    var api = model || {};
    api._decorators = {};

    function makeDecorator(col) {
        var decorator = grid.decorators.create(0, col, 1, 1, 'cell', 'real');


        decorator.getDecoratorLeft = function () {
            var firstRect = decorator.boundingBox && decorator.boundingBox.getClientRects() && decorator.boundingBox.getClientRects()[0] || {};
            return grid.viewPort.toGridX(firstRect.left) || 0;
        };

        if (api.annotateDecorator) {
            api.annotateDecorator(decorator);
        }


        return decorator;
    }

    api.makeDecorator = api.makeDecorator || makeDecorator;

    function ensureDecoratorPerCol() {
        for (var c = 0; c < grid.viewPort.cols; c++) {
            if (!api._decorators[c]) {
                if (api.isNeeded && !api.isNeeded(c)) {
                    continue;
                }
                var decorator = api.makeDecorator(c);
                api._decorators[c] = decorator;
                grid.decorators.add(decorator);
            }
        }
    }

    grid.eventLoop.bind('grid-viewport-change', function () {
        ensureDecoratorPerCol();
    });
    ensureDecoratorPerCol();

    return api;
};
},{}],30:[function(require,module,exports){
/*
 A simple package for creating a list of listeners that can be added to and notified
 */

module.exports = function () {
    var listeners = [];
    return {
        //returns a removal function to unbind the listener
        addListener: function (fn) {
            listeners.push(fn);
            return function () {
                listeners.splice(listeners.indexOf(fn), 1);
            };
        },
        notify: function (e) {
            listeners.forEach(function (listener) {
                listener(e);
            });
        }
    };
};
},{}],31:[function(require,module,exports){
var EVENT_NAMES = ['mousewheel', 'wheel', 'DOMMouseScroll'];

var api = {
    getDelta: function(event, xaxis) {
        if (event.wheelDelta) { //for everything but firefox
            var delta = event.wheelDeltaY;
            if (xaxis) {
                delta = event.wheelDeltaX;
            }
            return delta;

        } else if (event.detail) { //for firefox pre version 17
            if (event.axis && ((event.axis === 1 && xaxis) || (event.axis === 2 && !xaxis))) {
                return -1 * event.detail * 12;
            }
        } else if (event.deltaX || event.deltaY) {
            if (xaxis) {
                return -1 * event.deltaX;
            } else {
                return -1 * event.deltaY;
            }
        }
        return 0;
    },

    //binds a cross browser normalized mousewheel event, and returns a function that will unbind the listener;
    bind: function(elem, listener) {
        var normalizedListener = function(e) {
            listener(normalizeWheelEvent(e));
        };

        EVENT_NAMES.forEach(function(name) {
            elem.addEventListener(name, normalizedListener);
        });

        return function() {
            EVENT_NAMES.forEach(function(name) {
                elem.removeEventListener(name, normalizedListener);
            });
        };

    },
    normalize: normalizeWheelEvent
};

function normalizeWheelEvent(e) {
    var deltaX = api.getDelta(e, true);
    var deltaY = api.getDelta(e);
    var newEvent = Object.create(e, {
        deltaY: {
            value: deltaY
        },
        deltaX: {
            value: deltaX
        },
        type: {
            value: 'mousewheel'
        },
        target: {
            value: e.target
        },
        currentTarget: {
            value: e.currentTarget
        }
    });

    newEvent.preventDefault = function() {
        newEvent.defaultPrevented = true;
        if (e && e.preventDefault) {
            e.preventDefault();
        }
    };
    return newEvent;
}

module.exports = api;
},{}],32:[function(require,module,exports){
var key = require('key');
var arrow = key.code.arrow;
var util = require('../util');
var rangeUtil = require('../range-util');
var ctrlOrCmd = require('../ctrl-or-cmd');

module.exports = function(_grid) {
    var grid = _grid;

    var model = {
        focus: {
            row: 0,
            col: 0
        }
    };

    model.otherSelections = [];

    var focusClass = grid.cellClasses.create(0, 0, 'focus');
    grid.cellClasses.add(focusClass);

    model.focusDecorator = grid.decorators.create(0, 0, 1, 1);
    var focusDefaultRender = model.focusDecorator.render;
    model.focusDecorator.render = function() {
        var div = focusDefaultRender();
        div.setAttribute('class', 'grid-focus-decorator');
        return div;
    };
    grid.decorators.add(model.focusDecorator);

    model.setFocus = function setFocus(row, col, dontClearSelection, dontSetSelection) {
        row = grid.data.row.clamp(row);
        if (typeof row !== 'number' || isNaN(row)) {
            row = model.focus.row;
        }
        col = grid.data.col.clamp(col);
        if (typeof col !== 'number' || isNaN(col)) {
            col = model.focus.col;
        }
        var changed = row !== model.focus.row || col !== model.focus.col;
        model.focus.row = row;
        model.focus.col = col;
        focusClass.top = row;
        focusClass.left = col;
        model.focusDecorator.top = row;
        model.focusDecorator.left = col;
        grid.cellScrollModel.scrollIntoView(row, col);
        if (!dontClearSelection) {
            clearOtherSelections();
        }
        if (!dontSetSelection) {
            setSelectionToFocus();
        }
        if (changed) {
            grid.eventLoop.fire('grid-focus-change');
        }
    };

    function seekNextEdge(newIndex, startedDefined, isForwardEdge, isBackwardEdge, goForward) {

        var isEdgeToSeek;
        if (isForwardEdge(newIndex) || !startedDefined) {
            isEdgeToSeek = isBackwardEdge;
        } else {
            isEdgeToSeek = isForwardEdge;
        }


        while (goForward(newIndex) !== undefined && !isEdgeToSeek(newIndex = goForward(newIndex))) /*eslint-disable no-empty*/ {
            // empty
        } /*eslint-enable no-empty*/

        return newIndex;
    }

    function navFrom(row, col, e) {
        // if nothing changes great we'll stay where we are
        var newRow = row;
        var newCol = col;
        var isSeek = ctrlOrCmd(e);
        var isLeftwardEdge, isRightwardEdge, isUpwardEdge, isDownwardEdge, cellHasValue, startedDefined;
        if (isSeek) {
            cellHasValue = function(r, c) {
                if (r === undefined || c === undefined) {
                    return false;
                }

                return !!grid.dataModel.get(r, c).formatted;
            };
            isLeftwardEdge = function(c) {
                return cellHasValue(newRow, c) && !cellHasValue(newRow, grid.data.left(c));
            };
            isRightwardEdge = function(c) {
                return cellHasValue(newRow, c) && !cellHasValue(newRow, grid.data.right(c));
            };
            isUpwardEdge = function(r) {
                return cellHasValue(r, newCol) && !cellHasValue(grid.data.up(r), newCol);
            };
            isDownwardEdge = function(r) {
                return cellHasValue(r, newCol) && !cellHasValue(grid.data.down(r), newCol);
            };
            startedDefined = cellHasValue(newRow, newCol);
        }
        switch (e.which) {
            case arrow.down.code:
                if (isSeek) {
                    newRow = seekNextEdge(newRow, startedDefined, isDownwardEdge, isUpwardEdge, grid.data.down);
                } else {
                    newRow = grid.data.down(newRow);
                }
                break;
            case arrow.up.code:
                if (isSeek) {
                    newRow = seekNextEdge(newRow, startedDefined, isUpwardEdge, isDownwardEdge, grid.data.up);
                } else {
                    newRow = grid.data.up(newRow);
                }
                break;
            case arrow.right.code:
                if (isSeek) {
                    newCol = seekNextEdge(newCol, startedDefined, isRightwardEdge, isLeftwardEdge, grid.data.right);
                } else {
                    newCol = grid.data.right(newCol);
                }
                break;
            case arrow.left.code:
                if (isSeek) {
                    newCol = seekNextEdge(newCol, startedDefined, isLeftwardEdge, isRightwardEdge, grid.data.left);
                } else {
                    newCol = grid.data.left(newCol);
                }
                break;
        }
        if (newRow === undefined) {
            newRow = row;
        }
        if (newCol === undefined) {
            newCol = col;
        }
        return {
            row: newRow,
            col: newCol
        };
    }

    model._navFrom = navFrom;

    model.handleTabEvent = function(e) {
        var newCol = model.focus.col;
        var newRow = model.focus.row;
        if (!e || !e.shiftKey) {
            if (newCol === grid.data.col.count() - 1) {
                newRow = grid.data.down(newRow);
                newCol = 0;
            } else {
                newCol = grid.data.right(newCol);
            }
        } else {
            if (newCol === 0) {
                newRow = grid.data.up(newRow);
                newCol = grid.data.col.count() - 1;
            } else {
                newCol = grid.data.left(newCol);
            }
        }
        model.setFocus(newRow, newCol);
        e.preventDefault();
    }

    grid.eventLoop.bind('keydown', function(e) {
        if (!grid.focused) {
            return;
        }
        // handle tab
        if (key.is(key.code.special.tab, e.which)) {
            model.handleTabEvent(e);
            return;
        }

        if (!key.is(arrow, e.which)) {
            return;
        }
        // focus logic

        if (!e.shiftKey) {
            var newFocus = navFrom(model.focus.row, model.focus.col, e);
            model.setFocus(newFocus.row, newFocus.col, e);
        } else {
            // selection logic
            var newSelection;
            // stand in for if it's cleared
            if (model.selection.top === -1) {
                newSelection = {
                    top: model.focus.row,
                    left: model.focus.col,
                    height: 1,
                    width: 1
                };
            } else {
                newSelection = {
                    top: model.selection.top,
                    left: model.selection.left,
                    height: model.selection.height,
                    width: model.selection.width
                };
            }
            var navFromRow;
            var navFromCol;
            if (model.focus.row === newSelection.top) {
                navFromRow = newSelection.top + newSelection.height - 1;
            } else {
                navFromRow = newSelection.top;
            }

            if (model.focus.col === newSelection.left) {
                navFromCol = newSelection.left + newSelection.width - 1;
            } else {
                navFromCol = newSelection.left;
            }
            var newRowCol = navFrom(navFromRow, navFromCol, e);
            setSelectionFromPoints(model.focus.row, model.focus.col, newRowCol.row, newRowCol.col);
            grid.cellScrollModel.scrollIntoView(newRowCol.row, newRowCol.col);
        }
    });

    function isNavableMouseEvent(e) {
        var target = e.target;
        // if there's no target let it through because that only happens in unit tests,
        // or if it happened in real world it wouldn't have a valid row or col and so wouldn't do anything anyway
        return !target || grid.eventIsOnCells(e) && e.button !== 2;
    }

    grid.eventLoop.bind('mousedown', function(e) {
        if (!isNavableMouseEvent(e)) {
            return;
        }
        // assume the event has been annotated by the cell mouse model interceptor
        var row = e.row;
        var col = e.col;

        // if we're in checkbox mode pretend the user held command for header mousedowns only 
        var ctrlOrCmdPressed = model.checkboxMode && (row < 0 || col < 0) || ctrlOrCmd(e);

        if (e.shiftKey) {
            var fromRow = model.focus.row;
            var fromCol = model.focus.col;
            var toRow = row;
            var toCol = col;
            var wasSelected;
            if (toRow < 0) {
                wasSelected = grid.data.col.get(toCol).selected;
                fromRow = 0;
                toRow = Infinity;

            }
            if (toCol < 0) {
                wasSelected = grid.data.row.get(toRow).selected;
                fromCol = 0;
                toCol = Infinity;
            }

            selectFromFocusToCell(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed, wasSelected);
        } else {


            var focusRow = row;
            if (focusRow < 0) {
                focusRow = grid.view.row.toData(grid.rowModel.numHeaders());
            }
            var focusCol = col;
            if (focusCol < 0) {
                focusCol = grid.view.col.toData(grid.colModel.numHeaders());
            }

            var headerSelectionRange = createHeaderSelectionRange(row, col);
            if (headerSelectionRange) {
                var prevSelections = findFullRowOrColSelections(headerSelectionRange);
                if (prevSelections.length && model.checkboxMode) {
                    var selectAll = headerSelectionRange.width === Infinity && headerSelectionRange.height === Infinity && !(grid.rowModel.allSelected() || grid.colModel.allSelected());
                    prevSelections.forEach(function(prevSelection) {
                        removeFullRowOrColFromSelection(prevSelection, headerSelectionRange);
                    });
                    if (selectAll) {
                        model.setSelection(headerSelectionRange);
                    }
                    model.setFocus(focusRow, focusCol, true, true);
                } else {
                    if (ctrlOrCmdPressed && !selectionIsFocus(model.selection)) {
                        addSelection(model.selection);
                    } else {
                        clearOtherSelections();
                    }
                    model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);
                    model.setSelection(headerSelectionRange);
                }

            } else {
                if (ctrlOrCmdPressed) {
                    addSelection(model.selection);
                }
                model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);
            }
        }
    });

    function selectFromFocusToCell(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed, wasSelected) {

        if (!wasSelected || !model.checkboxMode) {
            setSelectionFromPoints(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed);
        } else {
            var range = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);
            var prevSelections = findFullRowOrColSelections(range);
            if (prevSelections.length) {
                prevSelections.forEach(function(prevSelection) {
                    removeFullRowOrColFromSelection(prevSelection, range);
                });
            }
        }
    }

    function createHeaderSelectionRange(row, col) {
        var headerSelectionRange;
        if (row < 0 && col < 0) {
            headerSelectionRange = rangeUtil.createFromPoints(0, 0, Infinity, Infinity);
        } else if (row < 0) {
            headerSelectionRange = rangeUtil.createFromPoints(0, col, Infinity, col);
        } else if (col < 0) {
            headerSelectionRange = rangeUtil.createFromPoints(row, 0, row, Infinity);
        }
        return headerSelectionRange;
    }

    function findSelectionByRange(range) {
        return model.getAllSelections().filter(function(selection) {
            return rangeUtil.equal(selection, range);
        })[0];
    }

    function addOrSetSelection(selection) {
        if (!selectionIsFocus(model.selection)) {
            addSelection(selection);
        } else {
            model.setSelection(selection);
        }
    }



    function removeFullRowOrColFromSelection(selection, rowOrCol) {

        if (rowOrCol.width === Infinity) { // row
            var newSelections = [];
            if (selection.top < rowOrCol.top) { // we need a selection for the top portion
                var newSelection = {
                    top: selection.top,
                    height: rowOrCol.top - selection.top,
                    left: selection.left,
                    width: selection.width
                };
                newSelections.push(newSelection);
            }

            var bottomRow = selection.top + selection.height - 1;
            if (bottomRow > rowOrCol.top + rowOrCol.height - 1) { // we need a selection for the bottom portion
                newSelections.push({
                    top: rowOrCol.top + rowOrCol.height,
                    height: bottomRow - (rowOrCol.top + rowOrCol.height - 1),
                    left: selection.left,
                    width: selection.width
                });
            }
            removeSelection(selection);
            newSelections.forEach(addOrSetSelection);
            syncSelectionToHeaders();
        }

        if (rowOrCol.height === Infinity) { // col
        }
    }

    function findFullRowOrColSelections(range) {
        return model.getAllSelections().filter(function(selection) {
            return (selection.height === Infinity && selection.top === 0 && rangeUtil.intersect([selection.left, selection.width], [range.left, range.width])) ||
                (selection.width === Infinity && selection.left === 0 && rangeUtil.intersect([selection.top, selection.height], [range.top, range.height]));
        });
    }

    function addSelection(range) {
        model.otherSelections.push(createAndAddSelectionDecorator(range.top, range.left, range.height, range.width));
    }

    model._rowSelectionClasses = [];
    model._colSelectionClasses = [];
    // row col selection
    function handleRowColSelectionChange(rowOrCol) {
        var decoratorsField = ('_' + rowOrCol + 'SelectionClasses');
        model[decoratorsField].forEach(function(selectionDecorator) {
            grid.cellClasses.remove(selectionDecorator);
        });
        model[decoratorsField] = [];

        if (grid[rowOrCol + 'Model'].allSelected()) {
            var top = rowOrCol === 'row' ? Infinity : 0;
            var left = rowOrCol === 'col' ? Infinity : 0;
            var decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');
            grid.cellClasses.add(decorator);
            model[decoratorsField].push(decorator);
        } else {
            grid[rowOrCol + 'Model'].getSelected().forEach(function(index) {
                var virtualIndex = grid[rowOrCol + 'Model'].toVirtual(index);
                var top = rowOrCol === 'row' ? virtualIndex : 0;
                var left = rowOrCol === 'col' ? virtualIndex : 0;
                var decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');
                grid.cellClasses.add(decorator);
                model[decoratorsField].push(decorator);
            });
        }
    }

    grid.eventLoop.bind('grid-row-selection-change', function() {
        handleRowColSelectionChange('row');
    });

    grid.eventLoop.bind('grid-col-selection-change', function() {
        handleRowColSelectionChange('col');
    });

    function createAndAddSelectionDecorator() {
        var selection = grid.decorators.create.apply(this, arguments);
        var defaultRender = selection.render;
        selection.render = function() {
            var div = defaultRender();
            div.setAttribute('class', 'grid-selection');
            return div;
        };
        grid.decorators.add(selection);
        return selection;
    }

    var selection = createAndAddSelectionDecorator();

    function syncSelectionToHeaders() {
        grid.colModel.clearSelected(true);
        grid.rowModel.clearSelected(true);
        model.getAllSelections().forEach(function(selection) {
            if (selection) {
                maybeSelectHeaderFromSelection(selection);
            }
        });
    }

    model.getAllSelections = function() {
        var selections = [];
        if (model.selection) {
            selections.push(model.selection);
        }
        return selections.concat(model.otherSelections);
    };

    function maybeSelectHeaderFromSelection(range, deselect) {
        var indexes;
        if (range.height === Infinity) {
            indexes = grid.data.col.indexes({
                from: range.left,
                length: range.width
            });
            if (deselect) {
                grid.colModel.deselect(indexes);
            } else {
                grid.colModel.select(indexes);
            }
        }
        if (range.width === Infinity) {
            indexes = grid.data.row.indexes({
                from: range.top,
                length: range.height
            });
            if (deselect) {
                grid.rowModel.deselect(indexes);
            } else {
                grid.rowModel.select(indexes);
            }
        }
    }

    function selectionIsFocus(selection) {
        return selection.height === 1 && selection.width === 1 && !model.otherSelections.length;
    }

    model.setSelection = function setSelection(newSelection) {
        var height = newSelection.height;
        var width = newSelection.width;
        if (selectionIsFocus(newSelection)) {
            height = -1;
            width = -1;
        }
        selection.top = newSelection.top;
        selection.left = newSelection.left;
        selection.height = height;
        selection.width = width;
        // select the columns to match
        syncSelectionToHeaders();
    };


    function setSelectionToFocus() {
        model.setSelection({
            top: model.focus.row,
            left: model.focus.col,
            height: 1,
            width: 1
        });
    }

    function clearOtherSelections() {
        grid.decorators.remove(model.otherSelections);
        model.otherSelections = [];
        syncSelectionToHeaders();
    }

    function removeSelection(selection) {
        if (rangeUtil.equal(selection, model.selection)) {
            if (model.otherSelections.length) {
                var lastSelection = model.otherSelections.pop();
                grid.decorators.remove(lastSelection);
                model.setSelection(lastSelection);
            } else {
                setSelectionToFocus();
            }
        } else {
            var index = model.otherSelections.indexOf(selection);
            if (index !== -1) {
                model.otherSelections.splice(index, 1);
                grid.decorators.remove(selection);
            }
        }
        syncSelectionToHeaders();
    }

    function setSelectionFromPoints(fromRow, fromCol, toRow, toCol, dontClearOthers) {
        if (!dontClearOthers) {
            clearOtherSelections();
        }
        toRow = util.clamp(toRow, 0, Infinity);
        toCol = util.clamp(toCol, 0, Infinity);
        var newSelection = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);
        model.setSelection(newSelection);
    }

    selection._onDragStart = function(e) {
        if (!isNavableMouseEvent(e)) {
            return;
        }
        if (e.enableAutoScroll) {
            e.enableAutoScroll();
        }
        var fromRow = model.focus.row;
        var fromCol = model.focus.col;
        var startCol = e.col;
        var startRow = e.row;
        var wasSelected;
        var toRow, toCol;
        if (startRow < 0) {
            // these are notted because mousedwon actually inverts the intial selection
            wasSelected = !grid.data.col.get(startCol).selected;
            fromRow = 0;
            toRow = Infinity;

        }
        if (startCol < 0) {
            // these are notted because mousedwon actually inverts the intial selection
            wasSelected = !grid.data.row.get(startRow).selected;
            fromCol = 0;
            toCol = Infinity;
        }
        var unbindDrag = grid.eventLoop.bind('grid-cell-drag', function(e) {
            toRow = toRow !== Infinity ? e.row : toRow;
            toCol = toCol !== Infinity ? e.col : toCol;

            var fixedRows = grid.rowModel.numFixed(true);
            if (startRow < fixedRows && toRow > fixedRows && toRow !== Infinity) {
                startRow = toRow = grid.rowModel.numFixed();
                grid.cellScrollModel.scrollTo(0, grid.cellScrollModel.col);
            }
            var fixedCols = grid.colModel.numFixed(true);
            if (startCol < fixedCols && toCol > fixedCols && toCol !== Infinity) {
                startCol = toCol = grid.colModel.numFixed();
                grid.cellScrollModel.scrollTo(grid.cellScrollModel.row, 0);
            }
            if (isNaN(toRow) || isNaN(toCol)) {
                return; //don't try to select when NaN
            }
            selectFromFocusToCell(fromRow, fromCol, toRow, toCol, true, wasSelected); // always pass true because if it was to be cleared mousedown should have handled that
        });
        var unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function() {
            unbindDrag();
            unbindDragEnd();
        });
    };

    grid.eventLoop.bind('grid-drag-start', selection._onDragStart);
    setSelectionToFocus();
    model._selectionDecorator = selection;

    Object.defineProperty(model, 'selection', {
        get: function() {
            if (selection.height === -1) { // cleared selection default to focus
                return {
                    top: model.focus.row,
                    left: model.focus.col,
                    height: 1,
                    width: 1
                };
            }
            return selection;
        }
    });

    model.getAllSelectedRanges = function() {
        var selectionRange = grid.navigationModel.selection;
        // valid selection range cannot go to -1
        if (selectionRange.top === -1) {
            selectionRange = {
                top: grid.navigationModel.focus.row,
                left: grid.navigationModel.focus.col,
                width: 1,
                height: 1
            };
        }
        return [selectionRange].concat(model.otherSelections);
    };

    model.clearSelection = function() {
        clearOtherSelections();
        setSelectionToFocus();
    }

    function clearSelectionFromModelChange(e) {
        if (e.action === 'size') { // don't clear for resize but all other changes for now will clear selection
            return;
        }
        model.clearSelection();

    }

    grid.eventLoop.bind('grid-col-change', clearSelectionFromModelChange);
    grid.eventLoop.bind('grid-row-change', clearSelectionFromModelChange);
    return model;
};
},{"../ctrl-or-cmd":23,"../range-util":37,"../util":42,"key":9}],33:[function(require,module,exports){
module.exports = function () {
    //a noop function to use
};
},{}],34:[function(require,module,exports){
module.exports = function () {
    return arguments[0];
};
},{}],35:[function(require,module,exports){
var util = require('../util');
var debounce = require('../debounce');
var capitalize = require('capitalize');

module.exports = function(_grid) {
    var grid = _grid;
    var model = {
        top: 0,
        left: 0,
        maxScroll: {},
        maxIsAllTheWayFor: {
            height: false,
            width: false
        }
    };
    var scrollBarWidth = 10;

    grid.eventLoop.bind('grid-virtual-pixel-cell-change', function() {
        var scrollHeight = grid.virtualPixelCellModel.totalHeight() - grid.virtualPixelCellModel.fixedHeight();
        var scrollWidth = grid.virtualPixelCellModel.totalWidth() - grid.virtualPixelCellModel.fixedWidth();
        model.setScrollSize(scrollHeight, scrollWidth);
        cacheMaxScroll();
        sizeScrollBars();
    });


    grid.eventLoop.bind('grid-viewport-change', function() {
        cacheMaxScroll();
        sizeScrollBars();
    });

    function cacheMaxScroll() {
        model.maxScroll.height = getMaxScroll('height');
        model.maxScroll.width = getMaxScroll('width');
    }

    //assumes a standardized wheel event that we create through the mousewheel package
    grid.eventLoop.bind('mousewheel', function handleMouseWheel(e) {
        if (getScrollParent(e.target, grid.container) !== grid.container) {
            return;
        }
        var deltaY = e.deltaY;
        var deltaX = e.deltaX;
        model.scrollTo(model.top - deltaY, model.left - deltaX, true);
        e.preventDefault();
        debouncedNotify();
    });

    model.setScrollSize = function(h, w) {
        model.height = h;
        model.width = w;
    };

    function notifyListeners() {
        //TODO: possibly keep track of delta since last update and send it along. for now, no
        grid.eventLoop.fire('grid-pixel-scroll');

        //update the cell scroll
        var scrollTop = model.top;
        var row = grid.virtualPixelCellModel.getRow(scrollTop + grid.virtualPixelCellModel.fixedHeight()) - grid.rowModel.numFixed();

        var scrollLeft = model.left;
        var col = grid.virtualPixelCellModel.getCol(scrollLeft + grid.virtualPixelCellModel.fixedWidth()) - grid.colModel.numFixed();

        grid.cellScrollModel.scrollTo(row, col, undefined, true);
    }

    var debouncedNotify = debounce(notifyListeners, 1);

    model.scrollTo = function(top, left, dontNotify) {
        model.top = util.clamp(top, 0, model.maxScroll.height);
        model.left = util.clamp(left, 0, model.maxScroll.width);
        positionScrollBars();

        if (!dontNotify) {
            notifyListeners();
        }


    };


    /* SCROLL BAR LOGIC */
    function getScrollPositionFromReal(scrollBarRealClickCoord, heightWidth, vertHorz) {
        var scrollBarTopClick = scrollBarRealClickCoord - grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();
        var scrollRatio = scrollBarTopClick / getMaxScrollBarCoord(heightWidth, vertHorz);
        var scrollCoord = scrollRatio * model.maxScroll[heightWidth];
        return scrollCoord;
    }

    function makeScrollBarDecorator(isHorz) {
        var decorator = grid.decorators.create();
        var xOrY = isHorz ? 'X' : 'Y';
        var heightWidth = isHorz ? 'width' : 'height';
        var vertHorz = isHorz ? 'horz' : 'vert';
        var gridCoordField = 'grid' + xOrY;
        var layerCoordField = 'layer' + xOrY;
        var viewPortClampFn = grid.viewPort['clamp' + xOrY];

        decorator.postRender = function(scrollBarElem) {
            scrollBarElem.setAttribute('class', 'grid-scroll-bar');
            decorator._onDragStart = function(e) {
                if (e.target !== scrollBarElem) {
                    return;
                }
                var scrollBarOffset = e[layerCoordField];

                decorator._unbindDrag = grid.eventLoop.bind('grid-drag', function(e) {
                    grid.eventLoop.stopBubbling(e);
                    var gridCoord = viewPortClampFn(e[gridCoordField]);
                    var scrollBarRealClickCoord = gridCoord - scrollBarOffset;
                    var scrollCoord = getScrollPositionFromReal(scrollBarRealClickCoord, heightWidth, vertHorz);
                    if (isHorz) {
                        model.scrollTo(model.top, scrollCoord);
                    } else {
                        model.scrollTo(scrollCoord, model.left);
                    }
                });

                decorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function() {
                    decorator._unbindDrag();
                    decorator._unbindDragEnd();
                });

                e.stopPropagation();
            };

            grid.eventLoop.bind('grid-drag-start', scrollBarElem, decorator._onDragStart);
            grid.eventLoop.bind('mousedown', scrollBarElem, function(e) {
                grid.eventLoop.stopBubbling(e);
            });

            return scrollBarElem;
        };

        decorator.units = 'px';
        decorator.space = 'real';

        return decorator;
    }

    model.vertScrollBar = makeScrollBarDecorator();
    model.horzScrollBar = makeScrollBarDecorator(true);
    model.vertScrollBar.width = scrollBarWidth;
    model.horzScrollBar.height = scrollBarWidth;

    function getMaxScroll(heightWidth) {
        if (model.maxIsAllTheWayFor[heightWidth]) {
            return model[heightWidth] - 1;
        }
        var rowOrCol = heightWidth === 'height' ? 'row' : 'col';
        var scrollLength = model[heightWidth];
        var viewScrollHeightOrWidth = getViewScrollHeightOrWidth(heightWidth);
        var firstScrollableCell = grid[rowOrCol + 'Model'].numFixed();
        while (scrollLength > viewScrollHeightOrWidth - 10) {
            scrollLength -= grid.virtualPixelCellModel[heightWidth](firstScrollableCell); - firstScrollableCell++;
        }
        return model[heightWidth] - scrollLength;

    }

    model._getMaxScroll = getMaxScroll;

    function getScrollRatioFromVirtualScrollCoords(scroll, heightWidth) {
        var maxScroll = model.maxScroll[heightWidth];
        var scrollRatio = scroll / maxScroll;
        return scrollRatio;
    }

    function getMaxScrollBarCoord(heightWidth, vertHorz) {
        return getViewScrollHeightOrWidth(heightWidth) - model[vertHorz + 'ScrollBar'][heightWidth];
    }

    function getRealScrollBarPosition(scroll, heightWidth, vertHorz) {
        var scrollRatio = getScrollRatioFromVirtualScrollCoords(scroll, heightWidth);
        var maxScrollBarScroll = getMaxScrollBarCoord(heightWidth, vertHorz);
        //in scroll bar coords
        var scrollBarCoord = scrollRatio * maxScrollBarScroll;
        //add the fixed height to translate back into real coords
        return scrollBarCoord + grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();
    }

    model._getRealScrollBarPosition = getRealScrollBarPosition;
    model._getScrollPositionFromReal = getScrollPositionFromReal;

    function calcScrollBarRealTop() {
        return getRealScrollBarPosition(model.top, 'height', 'vert');
    }

    function calcScrollBarRealLeft() {
        return getRealScrollBarPosition(model.left, 'width', 'horz');
    }

    function positionScrollBars() {
        model.vertScrollBar.top = calcScrollBarRealTop();
        model.horzScrollBar.left = calcScrollBarRealLeft();
    }

    function getViewScrollHeightOrWidth(heightWidth) {
        return grid.viewPort[heightWidth] - grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();
    }

    function getScrollableViewWidth() {
        return getViewScrollHeightOrWidth('width');
    }

    function getScrollableViewHeight() {
        return getViewScrollHeightOrWidth('height');
    }

    function sizeScrollBars() {
        model.vertScrollBar.left = grid.viewPort.width - scrollBarWidth;
        model.horzScrollBar.top = grid.viewPort.height - scrollBarWidth;
        var scrollableViewHeight = getScrollableViewHeight();
        var scrollableViewWidth = getScrollableViewWidth();
        model.vertScrollBar.height = Math.max(scrollableViewHeight / grid.virtualPixelCellModel.totalHeight() * scrollableViewHeight, 20);
        model.horzScrollBar.width = Math.max(scrollableViewWidth / grid.virtualPixelCellModel.totalWidth() * scrollableViewWidth, 20);
        if (model.vertScrollBar.height >= scrollableViewHeight) {
            model.vertScrollBar.height = -1;
        }

        if (model.horzScrollBar.width >= scrollableViewWidth) {
            model.horzScrollBar.width = -1;
        }
        positionScrollBars();
    }

    grid.decorators.add(model.vertScrollBar);
    grid.decorators.add(model.horzScrollBar);
    /* END SCROLL BAR LOGIC */

    function getScrollParent(elem, stopParent) {
        stopParent = stopParent || document;
        if (!elem) {
            return stopParent;
        }

        var position = elem.style.position,
            excludeStaticParent = position === 'absolute',
            overflowRegex = /(auto|scroll)/,
            scrollParent = elem;

        while (!!(scrollParent = scrollParent.parentElement) && scrollParent !== stopParent) {
            if (excludeStaticParent && scrollParent.style.position === 'static') {
                continue;
            }

            var computedStyle = getComputedStyle(scrollParent);

            if (overflowRegex.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
                break;
            }
        }

        return position === 'fixed' || !scrollParent || scrollParent === elem ? elem.ownerDocument || stopParent : scrollParent;
    }

    return model;
};
},{"../debounce":25,"../util":42,"capitalize":2}],36:[function(require,module,exports){
var addDirtyProps = require('../add-dirty-props');
module.exports = function(range, dirtyClean, parentDirtyClean, propOpts) {
    range = range || {}; //allow mixin functionality
    range.isDirty = dirtyClean.isDirty;

    var watchedProperties = ['top', 'left', 'height', 'width', 'units', 'space'];
    if (propOpts) {
        watchedProperties = watchedProperties.map(function(propName) {
            return {
                name: propName,
                onDirty: propOpts.onDirty,
                preDirty: propOpts.preDirty
            }
        });
    }
    var dirtyCleans = [dirtyClean];
    if (parentDirtyClean) {
        dirtyCleans.push(parentDirtyClean);
    }

    addDirtyProps(range, watchedProperties, dirtyCleans);
    // defaults
    range.units = 'cell';
    range.space = 'data';

    return range;
};
},{"../add-dirty-props":12}],37:[function(require,module,exports){
module.exports = {
    //takes a point and a length as the ranges in array form
    intersect: function(range1, range2) {
        var range2Start = range2[0];
        var range1Start = range1[0];
        var range1End = range1Start + range1[1] - 1;
        var range2End = range2Start + range2[1] - 1;
        if (range2Start > range1End || range2End < range1Start) {
            return null;
        }
        var resultStart = (range1Start > range2Start ? range1Start : range2Start);
        var resultEnd = (range1End < range2End ? range1End : range2End);
        return [
            resultStart,
            resultEnd - resultStart + 1
        ];
    },
    //takes a point and a length as the ranges in array form
    union: function(range1, range2) {
        if (!range1) {
            return range2;
        }
        if (!range2) {
            return range1;
        }
        var range2Start = range2[0];
        var range2End = range2Start + range2[1] - 1;
        var range1Start = range1[0];
        var range1End = range1Start + range1[1] - 1;
        var resultStart = (range1Start < range2Start ? range1Start : range2Start);
        return [
            resultStart, (range1End > range2End ? range1End : range2End) - resultStart + 1
        ];
    },

    //takes two row, col points and creates a normal position range
    createFromPoints: function(r1, c1, r2, c2) {
        var range = {};
        if (r1 < r2) {
            range.top = r1;
            range.height = r2 - r1 + 1;
        } else {
            range.top = r2;
            range.height = r1 - r2 + 1;
        }

        if (c1 < c2) {
            range.left = c1;
            range.width = c2 - c1 + 1;
        } else {
            range.left = c2;
            range.width = c1 - c2 + 1;
        }
        return range;
    },
    iterate: function() {
        var args = this.getArgs(arguments);
        var range = args.range;
        var cellFn = args.cellFn;
        var rowFn = args.rowFn;
        for (var r = range.top; r < range.top + range.height; r++) {
            var rowResult;
            if (rowFn) {
                rowResult = rowFn(r);
            }
            for (var c = range.left; c < range.left + range.width; c++) {
                if (cellFn) {
                    cellFn(r, c, rowResult);
                }
            }
        }
    },
    getArgs: function(args) {
        var range = args[0];
        var cellFn;
        var rowFn;
        if (args.length === 2) {
            cellFn = args[1];
        } else if (args.length === 3) {
            cellFn = args[2];
            rowFn = args[1];
        }
        return {
            range: range,
            cellFn: cellFn,
            rowFn: rowFn
        };
    },
    equal: function(r1, r2) {
        return r1.top === r2.top && r1.left === r2.left && r1.width === r2.width && r1.height === r2.height;
    }
};
},{}],38:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = require('../abstract-row-col-model')(grid, 'row', 'height', 30);

    return api;
};
},{"../abstract-row-col-model":11}],39:[function(require,module,exports){
module.exports = function(_grid) {
    var grid = _grid;

    var api = {
        _decorators: {}
    };

    function setColShowing(col) {
        grid.colModel.get(col).hidden = false;
    }

    function doWhileHidden(col, fn) {
        while (grid.colModel.get(col - 1).hidden) {
            col--;
            fn && fn(col);
        }
        return col;
    }

    function createDecorator(col, right) {
        var headerDecorator = grid.decorators.create(0, col, 1, 1, 'cell', 'virtual');

        headerDecorator.postRender = function(div) {

            if (right) {
                div.style.transform = 'translate(50%, -50%)';
                div.style.webkitTransform = 'translate(50%, -50%)';
                div.style.removeProperty('left');
            } else {
                div.style.transform = 'translate(-50%, -50%)';
                div.style.webkitTransform = 'translate(-50%, -50%)';
                div.style.removeProperty('right');
            }
            div.style.removeProperty('bottom');
            div.style.top = '50%';
            div.setAttribute('class', 'show-hidden-cols');
            div.setAttribute('dts', 'grid_column_unhide_btn');

            grid.eventLoop.bind('click', div, function() {
                doWhileHidden(col, setColShowing);
            });
        };
        return headerDecorator;
    }

    function maybeRemoveDecorator(col) {
        if (api._decorators[col]) {
            var decorator = api._decorators[col];
            grid.decorators.remove(decorator);
            api._decorators[col] = undefined;
        }
    }

    grid.eventLoop.bind('grid-col-change', function(e) {
        if (e.action === 'hide' || e.action === 'add') {
            e.descriptors.forEach(function(descriptor) {
                var col = descriptor.index;
                if (!col && col !== 0) {
                    return;
                }
                if (descriptor.hidden) {
                    var decCol = col + 1;
                    var rightSide = col === grid.colModel.length(true) - 1;
                    if (rightSide) {
                        //if we're last we actually have to backtrack to the last showing column
                        var lastHiddenCol = doWhileHidden(col);
                        decCol = lastHiddenCol - 1;

                    }
                    maybeRemoveDecorator(col);
                    var decorator = createDecorator(decCol, rightSide);
                    grid.decorators.add(decorator);
                    api._decorators[col] = decorator;
                } else {
                    maybeRemoveDecorator(col);
                }
            });
        }
    });

    return api;
};
},{}],40:[function(require,module,exports){
var util = require('../util');

module.exports = function(_grid) {
    var grid = _grid;

    var cellData = [];
    var headerData = [];
    var sortedCol;
    var ascending;
    var dirtyClean = require('../dirty-clean')(grid);
    var internalSet = function(data, r, c, datum) {
        if (!data[r]) {
            data[r] = [];
        }
        data[r][c] = datum;
        dirtyClean.setDirty();
    };

    var api = {
        isDirty: dirtyClean.isDirty,
        set: function(r, c, datum) {
            var data = arguments[0];
            if (!util.isArray(data)) {
                if (typeof datum === 'string') {
                    datum = {
                        value: datum.replace('[rR]', '').replace('[cC]', '').split(' ')
                    };
                }
                data = [{
                    row: r,
                    col: c,
                    data: datum
                }];
            }
            data.forEach(function(change) {
                internalSet(cellData, change.row, change.col, change.data);
            });
        },
        setHeader: function(r, c, datum) {
            internalSet(headerData, r, c, datum);
        },
        get: function(r, c) {
            var rowDescriptor = grid.rowModel.row(r);
            if (!rowDescriptor) {
                return {
                    formatted: ''
                };
            }
            var dataRow = cellData[rowDescriptor.dataRow];
            var datum = dataRow && dataRow[grid.colModel.col(c).dataCol];
            var value = datum && datum.value;
            if (value === undefined) {
                console.log((value && 'r' + value[0] + ' c' + value[1]) || '');
            }
            return {
                value: value,
                formatted: (value && (rowDescriptor.dataLayer ? ' s' + rowDescriptor.dataLayer + ' ' : '') + 'r' + value[0] + ' c' + value[1]) || ''
            };
        },
        getCopyData: function(r, c) {
            return api.get(r, c).formatted;
        },
        getHeader: function(r, c) {
            var dataRow = headerData[grid.rowModel.get(r).dataRow];

            var datum = dataRow && dataRow[grid.colModel.get(c).dataCol];
            var value = datum && datum.value;
            return {
                value: value,
                formatted: value && 'hr' + value[0] + ' hc' + value[1] || ''
            };
        },

        toggleSort: function(c) {
            var retVal = -1;
            var compareMethod = function(val1, val2) {
                return val1 < (val2) ? retVal : -1 * retVal;
            };
            if (c === sortedCol) {
                if (ascending) {
                    retVal = 1;
                }
                ascending = !ascending;
            } else {
                sortedCol = c;
                ascending = true;
            }
            cellData.sort(function(dataRow1, dataRow2) {
                if (!dataRow1 || !dataRow1[c]) {
                    return retVal;
                }
                if (!dataRow2 || !dataRow2[c]) {
                    return retVal * -1;
                }
                return compareMethod(dataRow1[c].value, dataRow2[c].value);
            });
            dirtyClean.setDirty();
        }
    };

    return api;
};
},{"../dirty-clean":27,"../util":42}],41:[function(require,module,exports){
module.exports.stringify = function (data) {
    var string = '';
    data.forEach(function (row, r) {
        row.forEach(function (value, c) {
            if (value.indexOf('\n') !== -1 || value.indexOf('\t') !== -1 || value.indexOf('"') !== -1) {
                //replace " with "" to escape and wrap the whole value in quotes 
                value = '"' + value.replace(/"/g, '""') + '"';
            }
            string += value;
            if (c !== row.length - 1) {
                string += '\t'
            }
        });
        if (r !== data.length - 1) {
            string += '\n';
        }

    });
    return string;
};

// ref: http://stackoverflow.com/a/1293163/2343
// This will parse a delimited string into an array of
// arrays. The default delimiter is the comma, but this
// can be overriden in the second argument.
function DSVToArray(strData, strDelimiter) {
    // Check to see if the delimiter is defined. If not,
    // then default to comma.
    strDelimiter = (strDelimiter || ",");

    // Create a regular expression to parse the CSV values.
    var objPattern = new RegExp(
        (
            // Delimiters.
        "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

            // Quoted fields.
        "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

            // Standard fields.
        "([^\"\\" + strDelimiter + "\\r\\n]+))"
        ),
        "gi"
    );


    // Create an array to hold our data. Give the array
    // a default empty first row.
    var arrData = [[]];

    // Create an array to hold our individual pattern
    // matching groups.
    var arrMatches = null;


    // Keep looping over the regular expression matches
    // until we can no longer find a match.
    while (arrMatches = objPattern.exec(strData)) {

        // Get the delimiter that was found.
        var strMatchedDelimiter = arrMatches[1];

        // Check to see if the given delimiter has a length
        // (is not the start of string) and if it matches
        // field delimiter. If id does not, then we know
        // that this delimiter is a row delimiter.
        if (
            strMatchedDelimiter.length &&
            strMatchedDelimiter !== strDelimiter
        ) {

            // Since we have reached a new row of data,
            // add an empty row to our data array.
            arrData.push([]);

        }

        var strMatchedValue;

        // Now that we have our delimiter out of the way,
        // let's check to see which kind of value we
        // captured (quoted or unquoted).
        if (arrMatches[2]) {

            // We found a quoted value. When we capture
            // this value, unescape any double quotes.
            strMatchedValue = arrMatches[2].replace(
                new RegExp("\"\"", "g"),
                "\""
            );

        } else {

            // We found a non-quoted value.
            strMatchedValue = arrMatches[3];

        }


        // Now that we have our value string, let's add
        // it to the data array.
        arrData[arrData.length - 1].push(strMatchedValue);
    }

    // Return the parsed data.
    return (arrData[0].length || !strData) && ( arrData ) || [[strData]];
}


module.exports.parse = function (string) {
    return DSVToArray(string, '\t');
};
},{}],42:[function(require,module,exports){
module.exports = {
    clamp: function(num, min, max, returnNaN) {
        if (num > max) {
            return returnNaN ? NaN : max;
        }
        if (num < min) {
            return returnNaN ? NaN : min;
        }
        return num;
    },
    isNumber: function(number) {
        return typeof number === 'number' && !isNaN(number);
    },
    isElement: function(node) {
        return !!(node &&
            (node.nodeName || // we are a direct element
                (node.prop && node.attr && node.find))); // we have an on and find method part of jquery API
    },
    isArray: function(value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    },
    position: function(elem, t, l, b, r) {
        if (t != null) {
            elem.style.top = t + 'px';
        }
        if (t != null) {
            elem.style.left = l + 'px';
        }
        if (t != null) {
            elem.style.bottom = b + 'px';
        }
        if (t != null) {
            elem.style.right = r + 'px';
        }
        elem.style.position = 'absolute';

    }
};
},{}],43:[function(require,module,exports){
var customEvent = require('../custom-event');
var debounce = require('../debounce');
var util = require('../util');


module.exports = function(_grid) {
    var viewLayer = {};

    var grid = _grid;
    var container;
    var root;
    var cellContainer;
    var decoratorContainer;
    var borderWidth;

    var GRID_CELL_CONTAINER_BASE_CLASS = 'grid-cells';
    var GRID_VIEW_ROOT_CLASS = 'js-grid-view-root';
    var CELL_CLASS = 'grid-cell';

    var cells; // matrix of rendered cell elements;
    var rows; // array of all rendered rows
    var builtCols; // map from col index to an array of built elements for the column to update on scroll
    var builtRows; // map from row index to an array of built elements for the row to update on scroll

    // add the cell classes through the standard method
    grid.cellClasses.add(grid.cellClasses.create(0, 0, CELL_CLASS, Infinity, Infinity, 'virtual'));

    var rowHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-row-header', Infinity, 0, 'virtual');
    var colHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-col-header', 0, Infinity, 'virtual');
    var fixedColClasses = grid.cellClasses.create(0, -1, 'grid-last-fixed-col', Infinity, 1, 'virtual');
    var fixedRowClasses = grid.cellClasses.create(-1, 0, 'grid-last-fixed-row', 1, Infinity, 'virtual');

    grid.cellClasses.add(rowHeaderClasses);
    grid.cellClasses.add(colHeaderClasses);
    grid.cellClasses.add(fixedRowClasses);
    grid.cellClasses.add(fixedColClasses);


    grid.eventLoop.bind('grid-col-change', function() {
        fixedColClasses.left = grid.colModel.numFixed() - 1;
        rowHeaderClasses.width = grid.colModel.numHeaders();
    });

    grid.eventLoop.bind('grid-row-change', function() {
        fixedRowClasses.top = grid.rowModel.numFixed() - 1;
        colHeaderClasses.height = grid.rowModel.numHeaders();
    });


    viewLayer.build = function(elem) {
        cleanup();

        container = elem;

        cellContainer = document.createElement('div');
        cellContainer.setAttribute('dts', 'grid-cells');
        cellContainer.setAttribute('class', GRID_CELL_CONTAINER_BASE_CLASS);
        util.position(cellContainer, 0, 0, 0, 0);
        cellContainer.style.zIndex = 0;

        decoratorContainer = document.createElement('div');
        decoratorContainer.setAttribute('dts', 'grid-decorators');
        util.position(decoratorContainer, 0, 0, 0, 0);
        decoratorContainer.style.zIndex = 0;
        decoratorContainer.style.pointerEvents = 'none';

        root = document.createElement('div');
        root.setAttribute('class', GRID_VIEW_ROOT_CLASS);

        root.appendChild(cellContainer);
        root.appendChild(decoratorContainer);

        container.appendChild(root);

    };


    function measureBorderWidth() {
        // read the border width, for the rare case of larger than 1px borders, otherwise the draw will default to 1
        if (borderWidth) {
            return;
        }
        var jsGridCell = cells[0] && cells[0][0];
        if (jsGridCell) {
            var oldClass = jsGridCell.className;
            jsGridCell.className = CELL_CLASS;
            var computedStyle = getComputedStyle(jsGridCell);
            var borderWidthProp = computedStyle.getPropertyValue('border-left-width');
            borderWidth = parseInt(borderWidthProp);
            jsGridCell.className = oldClass;
        }
        borderWidth = isNaN(borderWidth) || !borderWidth ? undefined : borderWidth;
        return borderWidth;
    }

    // only draw once per js turn, may need to create a synchronous version
    viewLayer.draw = debounce(function() {
        viewLayer._draw();
    }, 1);

    viewLayer._draw = function() {
        // return if we haven't built yet
        if (!container) {
            return;
        }

        var rebuilt = grid.viewPort.isDirty();
        if (rebuilt) {
            viewLayer._buildCells(cellContainer);
        }

        var builtColsDirty = grid.colModel.areBuildersDirty();
        if (rebuilt || builtColsDirty) {
            viewLayer._buildCols();
        }

        var builtRowsDirty = grid.rowModel.areBuildersDirty();
        if (rebuilt || builtRowsDirty) {
            viewLayer._buildRows();
        }

        var cellsPositionOrSizeChanged = grid.colModel.isDirty() || grid.rowModel.isDirty() || grid.cellScrollModel.isDirty();

        if (grid.cellClasses.isDirty() || rebuilt || cellsPositionOrSizeChanged) {
            viewLayer._drawCellClasses();
        }

        if (rebuilt || cellsPositionOrSizeChanged || builtColsDirty || builtRowsDirty || grid.dataModel.isDirty()) {
            viewLayer._drawCells();
        }

        if (grid.decorators.isDirty() || rebuilt || cellsPositionOrSizeChanged) {
            viewLayer._drawDecorators(cellsPositionOrSizeChanged);
        }

        grid.eventLoop.fire('grid-draw');
    };

    /* CELL LOGIC */
    function getBorderWidth() {
        return borderWidth || 1;
    }

    viewLayer._drawCells = function() {
        measureBorderWidth();
        var bWidth = getBorderWidth();
        var headerRows = grid.rowModel.numHeaders();
        var headerCols = grid.colModel.numHeaders();
        var totalVisibleCellWidth = 0;
        var lastVirtualCol;
        var lastVirtualRow;
        // these get calculated once per col and are then cached to save a factor of numRows calls per column
        var widths = [];
        var lefts = [];
        var virtualCols = [];

        grid.viewPort.iterateCells(function drawCell(r, c) {
            var cell = cells[r][c];
            // only calculate these once per column since they can't change during draw
            var width = widths[c] || (widths[c] = grid.viewPort.getColWidth(c));
            var virtualCol = virtualCols[c] || (virtualCols[c] = grid.viewPort.toVirtualCol(c));
            // if we got the same vCol we've been clamped and its time to hide this cell
            // also hide the cell if its width is zero cause ya...
            if (width === 0 || virtualCol === lastVirtualCol) {
                cell.style.display = 'none';
                return;
            }
            if (r === 0) {
                // calculate width for rows later but only do it one time (so on the first row)
                totalVisibleCellWidth += width;
            }

            lastVirtualCol = virtualCol;
            cell.style.display = '';
            cell.style.width = width + bWidth + 'px';
            // only calculate these once per column since they can't change during draw
            var left = lefts[c] || (lefts[c] = grid.viewPort.getColLeft(c));

            cell.style.left = left + 'px';


            var virtualRow = grid.viewPort.toVirtualRow(r);

            var data;
            if (r < headerRows || c < headerCols) {
                data = grid.dataModel.getHeader(virtualRow, virtualCol);
            } else {
                data = grid.dataModel.get(grid.rowModel.toData(virtualRow), grid.colModel.toData(virtualCol));
            }
            // artificially only get builders for row headers for now
            var builder = virtualRow < headerRows && grid.rowModel.get(virtualRow).builder || undefined;
            var hasRowBuilder = true;
            if (!builder) {
                hasRowBuilder = false;
                builder = grid.colModel.get(virtualCol).builder;
            }

            var cellChild;
            if (builder) {
                var builtElem;
                if (hasRowBuilder) {
                    builtElem = builtRows[virtualRow][c];
                } else {
                    builtElem = builtCols[virtualCol][r];
                }
                cellChild = builder.update(builtElem, {
                    virtualCol: virtualCol,
                    virtualRow: virtualRow,
                    data: data
                });
            }
            // if we didn't get a child from the builder use a regular text node
            if (!cellChild) {
                viewLayer.setTextContent(cell, data.formatted);
            } else {
                var notSameElem = cell.firstChild !== cellChild;
                if (cell.firstChild && notSameElem) {
                    cell.removeChild(cell.firstChild);
                }
                if (notSameElem) {
                    cell.appendChild(cellChild);
                }

            }
        }, function drawRow(r) {
            var height = grid.viewPort.getRowHeight(r);
            var row = rows[r];
            var virtualRow = grid.view.row.toVirtual(r);
            // seeing the same virtual row twice means we've been clamped and it's time to hide the row
            if (height === 0 || lastVirtualRow === virtualRow) {
                row.style.display = 'none';
                return;
            }
            lastVirtualRow = virtualRow;
            row.style.display = '';
            row.style.height = height + bWidth + 'px';
            var top = grid.viewPort.getRowTop(r);
            row.style.top = top + 'px';
        });

        rows.forEach(function(row) {
            row.style.width = totalVisibleCellWidth + 'px';
        });

        if (grid.cellScrollModel.row % 2) {
            cellContainer.className = GRID_CELL_CONTAINER_BASE_CLASS + ' odds';
        } else {
            cellContainer.className = GRID_CELL_CONTAINER_BASE_CLASS;
        }
    };


    viewLayer._buildCells = function buildCells(cellContainer) {
        while (cellContainer.firstChild) {
            cellContainer.removeChild(cellContainer.firstChild);
        }


        cells = [];
        rows = [];
        var row;
        grid.viewPort.iterateCells(function(r, c) {
            var cell = buildDivCell();
            cells[r][c] = cell;
            row.appendChild(cell);
        }, function(r) {
            cells[r] = [];
            row = document.createElement('div');
            row.setAttribute('class', 'grid-row');
            row.setAttribute('dts', 'grid-row');
            row.style.position = 'absolute';
            row.style.left = 0;
            rows[r] = row;
            cellContainer.appendChild(row);
        });
    };

    function buildDivCell() {
        var cell = document.createElement('div');
        cell.setAttribute('dts', 'grid-cell');
        var style = cell.style;
        style.position = 'absolute';
        style.boxSizing = 'border-box';
        style.top = '0px';
        style.bottom = '0px';
        return cell;
    }

    /* END CELL LOGIC */

    /* COL BUILDER LOGIC */

    function destroyRenderedElems(oldElems) {
        if (!oldElems) {
            return;
        }
        oldElems.forEach(function(oldElem) {
            if (!oldElem) {
                return;
            }
            var destroyEvent = customEvent('grid-rendered-elem-destroy', true);
            oldElem.dispatchEvent(destroyEvent);
        });
    }

    viewLayer._buildCols = function() {
        var previouslyBuiltCols = builtCols;
        builtCols = {};
        for (var c = 0; c < grid.colModel.length(true); c++) {
            var builder = grid.colModel.get(c).builder;
            var oldElems = previouslyBuiltCols && previouslyBuiltCols[c];

            if (builder) {
                builtCols[c] = [];
                destroyRenderedElems(oldElems);
                for (var realRow = 0; realRow < grid.viewPort.rows; realRow++) {
                    builtCols[c][realRow] = builder.render({
                        viewRow: realRow,
                        previousElement: oldElems && oldElems[realRow]
                    });
                }
            }
        }
    };
    /* END COL BUILDER LOGIC */

    /* ROW BUILDER LOGIC
     *  for now we only build headers
     * */

    viewLayer._buildRows = function() {
        var previouslyBuiltRows = builtRows;
        builtRows = {};
        for (var r = 0; r < grid.rowModel.numHeaders(); r++) {
            var builder = grid.rowModel.get(r).builder;
            var oldElems = previouslyBuiltRows && previouslyBuiltRows[r];

            if (builder) {
                builtRows[r] = [];
                destroyRenderedElems(oldElems);
                for (var realCol = 0; realCol < grid.viewPort.cols; realCol++) {
                    builtRows[r][realCol] = builder.render({
                        viewCol: realCol,
                        previousElement: oldElems && oldElems[realCol]
                    });
                }
            }
        }
    };
    /* END ROW BUILDER LOGIC*/

    /* DECORATOR LOGIC */
    function setPosition(boundingBox, top, left, height, width) {
        var style = boundingBox.style;
        if (height <= 0 || width <= 0) {
            style.display = 'none';
            return;
        }
        style.display = ''
        style.top = top + 'px';
        style.left = left + 'px';
        style.height = height + 'px';
        style.width = width + 'px';
        style.position = 'absolute';
    }

    function positionDecorator(bounding, t, l, h, w) {
        setPosition(bounding, t, l, util.clamp(h, 0, grid.viewPort.height), util.clamp(w, 0, grid.viewPort.width));
    }

    function positionCellDecoratorFromViewCellRange(realCellRange, boundingBox) {
        var realPxRange = grid.viewPort.toPx(realCellRange);
        positionDecorator(boundingBox, realPxRange.top, realPxRange.left, realPxRange.height && realPxRange.height + getBorderWidth(), realPxRange.width && realPxRange.width + getBorderWidth());
    }

    function createRangeForDescriptor(descriptor) {
        var range = {
            top: descriptor.top,
            left: descriptor.left,
            height: descriptor.height,
            width: descriptor.width
        };
        if (descriptor.space === 'data' && descriptor.units === 'cell') {
            range.top += grid.rowModel.numHeaders();
            range.left += grid.colModel.numHeaders();
        }
        return range;
    }

    viewLayer._drawDecorators = function(cellsPositionOrSizeChanged) {
        var aliveDecorators = grid.decorators.getAlive();
        aliveDecorators.forEach(function(decorator) {

            var boundingBox = decorator.boundingBox;
            if (!boundingBox) {
                boundingBox = document.createElement('div');
                boundingBox.style.pointerEvents = 'none';
                decorator.boundingBox = boundingBox;
                var decElement = decorator.render();
                if (decElement) {
                    boundingBox.appendChild(decElement);
                    decoratorContainer.appendChild(boundingBox);
                }
            }

            if (decorator.isDirty() || cellsPositionOrSizeChanged) {
                if (decorator.space === 'real') {
                    switch (decorator.units) {
                        case 'px':
                            positionDecorator(boundingBox, decorator.top, decorator.left, decorator.height, decorator.width);
                            break;
                        case 'cell':
                            positionCellDecoratorFromViewCellRange(decorator, boundingBox);
                            break;
                    }
                } else if (decorator.space === 'virtual' || decorator.space === 'data') {
                    switch (decorator.units) {
                        case 'px':
                            break;
                        case 'cell':
                            /* jshint -W086 */
                        default:
                            var range = createRangeForDescriptor(decorator);
                            var realCellRange = grid.viewPort.intersect(range);
                            if (realCellRange) {
                                positionCellDecoratorFromViewCellRange(realCellRange, boundingBox);
                            } else {
                                positionDecorator(boundingBox, -1, -1, -1, -1);
                            }
                            break;
                            /* jshint +W086 */
                    }

                }
            }
        });

        removeDecorators(grid.decorators.popAllDead());
    };

    function removeDecorators(decorators) {
        decorators.forEach(function(decorator) {
            var boundingBox = decorator.boundingBox;
            if (boundingBox) {
                // if they rendered an element previously we attached it to the bounding box as the only child
                var renderedElement = boundingBox.firstChild;
                if (renderedElement) {
                    // create a destroy dom event that bubbles
                    var destroyEvent = customEvent('decorator-destroy', true);
                    renderedElement.dispatchEvent(destroyEvent);
                }
                decoratorContainer.removeChild(boundingBox);
                decorator.boundingBox = undefined;
            }
        });
    }

    /* END DECORATOR LOGIC */

    /* CELL CLASSES LOGIC */
    viewLayer._drawCellClasses = function() {
        grid.viewPort.iterateCells(function(r, c) {
            var classes = grid.cellClasses.getCachedClasses(grid.view.row.toVirtual(r), grid.view.col.toVirtual(c));
            cells[r][c].className = classes.join(' ');
        });
    };

    /* END CELL CLASSES LOGIC*/

    viewLayer.setTextContent = function(elem, text) {
        if (elem.firstChild && elem.firstChild.nodeType === 3) {
            elem.firstChild.nodeValue = text;
        } else {
            elem.textContent = text;
        }
    };

    function destroyPreviouslyBuilt(built) {
        if (!built) {
            return;
        }
        Object.keys(built).forEach(function(key) {
            destroyRenderedElems(built[key]);
        });
    }

    function cleanup() {
        removeDecorators(grid.decorators.getAlive().concat(grid.decorators.popAllDead()));
        destroyPreviouslyBuilt(builtCols);
        destroyPreviouslyBuilt(builtRows);
        if (!container) {
            return;
        }
        var querySelectorAll = container.querySelectorAll('.' + GRID_VIEW_ROOT_CLASS);
        for (var i = 0; i < querySelectorAll.length; ++i) {
            var root = querySelectorAll[i];
            container.removeChild(root);
        }
    }

    grid.eventLoop.bind('grid-destroy', function() {
        cleanup();
        clearTimeout(viewLayer.draw.timeout);
        viewLayer.draw = require('../no-op');
    });

    return viewLayer;
};
},{"../custom-event":24,"../debounce":25,"../no-op":33,"../util":42}],44:[function(require,module,exports){
var util = require('../util');
var rangeUtil = require('../range-util');
var capitalize = require('capitalize');
var addDirtyProps = require('../add-dirty-props');
var debounce = require('../debounce');

module.exports = function(_grid) {
    var grid = _grid;
    var dirtyClean = require('../dirty-clean')(grid);
    var container;

    var viewPort = addDirtyProps({}, ['rows', 'cols', 'width', 'height'], [dirtyClean]);
    viewPort.rows = 0;
    viewPort.cols = 0;
    viewPort.isDirty = dirtyClean.isDirty;

    // these probably trigger reflow so we may need to think about caching the value and updating it at on draws or something
    function getFirstClientRect() {
        return container && container.getClientRects && container.getClientRects() && container.getClientRects()[0] || {};
    }

    Object.defineProperty(viewPort, 'top', {
        enumerable: true,
        get: function() {
            return getFirstClientRect().top || 0;
        }
    });

    Object.defineProperty(viewPort, 'left', {
        enumerable: true,
        get: function() {
            return getFirstClientRect().left || 0;
        }
    });

    viewPort.toGridX = function(clientX) {
        return clientX - viewPort.left;
    };

    viewPort.toGridY = function(clientY) {
        return clientY - viewPort.top;
    };


    var fixed = {
        rows: 0,
        cols: 0
    };

    function getFixed(rowOrCol) {
        return fixed[rowOrCol + 's'];
    }

    viewPort.sizeToContainer = function(elem) {
        container = elem;
        viewPort.width = elem.offsetWidth;
        viewPort.height = elem.offsetHeight;
        viewPort.rows = calculateMaxLengths(viewPort.height, grid.rowModel);
        viewPort.cols = calculateMaxLengths(viewPort.width, grid.colModel);
        grid.eventLoop.fire('grid-viewport-change');
    };

    viewPort._onResize = debounce(function() {
        viewPort._resize();
    }, 200);

    grid.eventLoop.bind('grid-destroy', function() {
        clearTimeout(viewPort._onResize.timeout);
        clearTimeout(shortDebouncedResize.timeout);
    });

    viewPort._resize = function() {
        if (container) {
            viewPort.sizeToContainer(container);
        }
    };

    var shortDebouncedResize = debounce(function() {
        viewPort._resize();
    }, 1);

    viewPort.shortDebouncedResize = shortDebouncedResize;


    grid.eventLoop.bind('resize', window, function() {
        //we don't bind the handler directly so that tests can mock it out
        viewPort._onResize();
    });

    grid.eventLoop.bind('grid-row-change', function() {
        fixed.rows = grid.rowModel.numFixed();
        shortDebouncedResize();
    });

    grid.eventLoop.bind('grid-col-change', function() {
        fixed.cols = grid.colModel.numFixed();
        shortDebouncedResize();
    });

    function convertRealToVirtual(coord, rowOrCol, coordIsVirtual) {
        // could cache this on changes i.e. row-change or col-change events
        var numFixed = getFixed(rowOrCol);
        if (coord < numFixed) {
            return coord;
        }
        return coord + (coordIsVirtual ? -1 : 1) * grid.cellScrollModel[rowOrCol];
    }

    // converts a viewport row or column to a real row or column
    // clamps it if the column would be outside the range
    function getVirtualRowColUnsafe(realCoord, rowOrCol) {
        return convertRealToVirtual(realCoord, rowOrCol);
    }

    function getVirtualRowColClamped(viewCoord, rowOrCol) {
        var virtualRowCol = getVirtualRowColUnsafe(viewCoord, rowOrCol);
        return grid.virtualPixelCellModel['clamp' + capitalize(rowOrCol)](virtualRowCol);
    }

    viewPort.toVirtualRow = function(r) {
        return getVirtualRowColClamped(r, 'row');
    };

    viewPort.toVirtualCol = function(c) {
        return getVirtualRowColClamped(c, 'col');
    };

    function getRealRowColClamped(virtualCoord, rowOrCol) {
        var numFixed = getFixed(rowOrCol);
        if (virtualCoord < numFixed) {
            return virtualCoord;
        }
        var maxViewPortIndex = viewPort[rowOrCol + 's'] - 1;
        return util.clamp(virtualCoord - grid.cellScrollModel[rowOrCol], numFixed, maxViewPortIndex, true);
    }

    viewPort.rowIsInView = function(virtualRow) {
        var realRow = viewPort.toRealRow(virtualRow);
        return !isNaN(realRow) && getLengthBetweenViewCoords(0, realRow, 'row', 'height', true) < viewPort.height;
    };

    viewPort.colIsInView = function(virtualCol) {
        var realCol = viewPort.toRealCol(virtualCol);
        return !isNaN(realCol) && getLengthBetweenViewCoords(0, realCol, 'col', 'width', true) < viewPort.width;
    };


    // default unclamped cause that seems to be the more likely use case converting this direction
    viewPort.toRealRow = function(virtualRow) {
        return getRealRowColClamped(virtualRow, 'row');
    };

    viewPort.toRealCol = function(virtualCol) {
        return getRealRowColClamped(virtualCol, 'col');
    };

    viewPort.clampRow = function(r) {
        return util.clamp(r, 0, viewPort.rows - 1);
    };

    viewPort.clampCol = function(c) {
        return util.clamp(c, 0, viewPort.cols - 1);
    };

    viewPort.clampY = function(y) {
        return util.clamp(y, 0, viewPort.height);
    };

    viewPort.clampX = function(x) {
        return util.clamp(x, 0, viewPort.width);
    };

    function getLengthBetweenViewCoords(startCoord, endCoord, rowOrCol, heightOrWidth, inclusive) {
        var rowOrColCap = capitalize(rowOrCol);
        var toVirtual = viewPort['toVirtual' + rowOrColCap];
        var lengthFn = grid.virtualPixelCellModel[heightOrWidth];
        var clampFn = viewPort['clamp' + rowOrColCap];
        var pos = 0;
        var numFixed = getFixed(rowOrCol);
        var isInNonfixedArea = endCoord >= numFixed;
        var isInFixedArea = startCoord < numFixed;
        var exclusiveOffset = (inclusive ? 0 : 1);
        if (isInFixedArea) {
            var fixedEndCoord = (isInNonfixedArea ? numFixed - 1 : endCoord - exclusiveOffset);
            pos += lengthFn(startCoord, fixedEndCoord);
        }
        if (isInNonfixedArea) {
            pos += lengthFn((isInFixedArea ? toVirtual(numFixed) : toVirtual(startCoord)), toVirtual(clampFn(endCoord)) - exclusiveOffset);
        }
        return pos;
    }

    function getTopOrLeft(endCoord, rowOrCol, heightOrWidth) {
        return getLengthBetweenViewCoords(0, endCoord, rowOrCol, heightOrWidth);
    }

    viewPort.getRowTop = function(viewPortCoord) {
        return getTopOrLeft(viewPortCoord, 'row', 'height');
    };

    viewPort.getColLeft = function(viewPortCol) {
        return getTopOrLeft(viewPortCol, 'col', 'width');
    };

    viewPort.toPx = function(realCellRange) {
        return {
            top: viewPort.getRowTop(realCellRange.top),
            left: viewPort.getColLeft(realCellRange.left),
            height: getLengthBetweenViewCoords(realCellRange.top, realCellRange.top + realCellRange.height - 1, 'row', 'height', true),
            width: getLengthBetweenViewCoords(realCellRange.left, realCellRange.left + realCellRange.width - 1, 'col', 'width', true)
        };
    };

    function getRowOrColFromPosition(pos, rowOrCol, heightOrWidth, returnVirtual) {
        // we could do this slighly faster with binary search to get log(n) instead of n, but will only do it if we actually need to optimize this
        var rowOrColCap = capitalize(rowOrCol);
        var viewMax = viewPort[rowOrCol + 's'];
        var toVirtual = viewPort['toVirtual' + rowOrColCap];
        var lengthFn = grid.virtualPixelCellModel[heightOrWidth];
        var summedLength = 0;
        for (var i = 0; i < viewMax; i++) {
            var virtual = toVirtual(i);
            var length = lengthFn(virtual);
            var newSum = summedLength + length;
            if (newSum > pos) {
                return returnVirtual ? virtual : i;
            }
            summedLength = newSum;
        }
        return NaN;
    }

    viewPort.getVirtualRowByTop = function(top) {
        return getRowOrColFromPosition(top, 'row', 'height', true);
    };

    viewPort.getVirtualColByLeft = function(left) {
        return getRowOrColFromPosition(left, 'col', 'width', true);
    };

    viewPort.getRowByTop = function(top) {
        return getRowOrColFromPosition(top, 'row', 'height');
    };

    viewPort.getColByLeft = function(left) {
        return getRowOrColFromPosition(left, 'col', 'width');
    };

    viewPort.getRowHeight = function(viewPortRow) {
        return grid.virtualPixelCellModel.height(viewPort.toVirtualRow(viewPort.clampRow(viewPortRow)));
    };

    viewPort.getColWidth = function(viewPortCol) {
        return grid.virtualPixelCellModel.width(viewPort.toVirtualCol(viewPort.clampCol(viewPortCol)));
    };

    function intersectRowsOrCols(intersection, range, topOrLeft, rowOrCol, heightOrWidth) {
        var numFixed = fixed[rowOrCol + 's'];
        var fixedRange = [0, numFixed];

        var virtualRange = [range[topOrLeft], range[heightOrWidth]];
        var fixedIntersection = rangeUtil.intersect(fixedRange, virtualRange);
        var scrollRange = [numFixed, viewPort[rowOrCol + 's'] - numFixed];
        virtualRange[0] -= grid.cellScrollModel[rowOrCol];
        var scrollIntersection = rangeUtil.intersect(scrollRange, virtualRange);
        var resultRange = rangeUtil.union(fixedIntersection, scrollIntersection);
        if (!resultRange) {
            return null;
        }

        intersection[topOrLeft] = resultRange[0];
        intersection[heightOrWidth] = resultRange[1];
        return intersection;
    }

    viewPort.intersect = function(range) {
        // assume virtual cells for now
        var intersection = intersectRowsOrCols({}, range, 'top', 'row', 'height');
        if (!intersection) {
            return null;
        }
        return intersectRowsOrCols(intersection, range, 'left', 'col', 'width');
    };


    function calculateMaxLengths(totalLength, lengthModel) {
        var lengthMethod = lengthModel.width && grid.virtualPixelCellModel.width || grid.virtualPixelCellModel.height;
        var numFixed = lengthModel.numFixed();
        var windowLength = 0;
        var maxSize = 0;
        var fixedLength = 0;
        var windowStartIndex = numFixed;

        for (var fixed = 0; fixed < numFixed; fixed++) {
            fixedLength += lengthMethod(fixed);
        }

        // it might be safer to actually sum the lengths in the virtualPixelCellModel but for now here is ok
        for (var index = numFixed; index < lengthModel.length(true); index++) {
            var lengthOfIindex = lengthMethod(index);
            windowLength += lengthOfIindex;
            while (windowLength + fixedLength > totalLength && windowStartIndex < index) {
                windowLength -= lengthMethod(windowStartIndex);
                windowStartIndex++;
            }
            var windowSize = index - windowStartIndex + 1; // add the one because we want the last index that didn't fit
            if (windowSize > maxSize) {
                maxSize = windowSize;
            }

        }
        return Math.min(maxSize + numFixed + 1, grid.virtual[lengthModel.width ? 'col' : 'row'].count());
    }


    viewPort.iterateCells = function(cellFn, optionalRowFn, optionalMaxRow, optionalMaxCol) {
        optionalMaxRow = optionalMaxRow || Infinity;
        optionalMaxCol = optionalMaxCol || Infinity;
        for (var r = 0; r < Math.min(viewPort.rows, optionalMaxRow); r++) {
            if (optionalRowFn) {
                optionalRowFn(r);
            }
            if (cellFn) {
                for (var c = 0; c < Math.min(viewPort.cols, optionalMaxCol); c++) {
                    cellFn(r, c);

                }
            }
        }
    };

    return viewPort;
}
},{"../add-dirty-props":12,"../debounce":25,"../dirty-clean":27,"../range-util":37,"../util":42,"capitalize":2}],45:[function(require,module,exports){
var util = require('../util');

module.exports = function (_grid) {
    var grid = _grid;
    var model = {};

    //all pixels are assumed to be in the virtual world, no real world pixels are dealt with here :)
    model.getRow = function (topPx) {
        if (topPx < 0) {
            return NaN;
        }
        var sumLength = 0;
        for (var r = 0; r < grid.rowModel.length(true); r++) {
            sumLength += grid.rowModel.height(r);
            if (topPx < sumLength) {
                return r;
            }
        }
        return NaN;
    };

    //yes these are very similar but there will be differences
    model.getCol = function (leftPx) {
        if (leftPx < 0) {
            return NaN;
        }
        var sumLength = 0;
        for (var c = 0; c < grid.colModel.length(true); c++) {
            sumLength += grid.colModel.width(c);
            if (leftPx < sumLength) {
                return c;
            }
        }
        return NaN;
    };


    function clampRowOrCol(virtualRowCol, rowOrCol) {
        var maxRowCol = grid[rowOrCol + 'Model'].length(true) - 1;
        return util.clamp(virtualRowCol, 0, maxRowCol);
    }

    model.clampRow = function (virtualRow) {
        return clampRowOrCol(virtualRow, 'row');
    };

    model.clampCol = function (virtualCol) {
        return clampRowOrCol(virtualCol, 'col');
    };

    //for now these just call through to the row and column model, but very likely it will need to include some other calculations
    model.height = function (virtualRowStart, virtualRowEnd) {
        return heightOrWidth(virtualRowStart, virtualRowEnd, 'row');
    };

    model.width = function (virtualColStart, virtualColEnd) {
        return heightOrWidth(virtualColStart, virtualColEnd, 'col');
    };

    function heightOrWidth(start, end, rowOrCol) {
        var length = 0;
        if (end < start) {
            return 0;
        }
        end = util.isNumber(end) ? end : start;
        end = clampRowOrCol(end, rowOrCol);
        start = clampRowOrCol(start, rowOrCol);
        var lengthModel = grid[rowOrCol + 'Model'];
        var lengthFn = lengthModel.width || lengthModel.height;
        for (var i = start; i <= end; i++) {
            length += lengthFn(i);
        }
        return length;
    }

    model.totalHeight = function () {
        return model.height(0, grid.rowModel.length(true) - 1);
    };

    model.totalWidth = function () {
        return model.width(0, grid.colModel.length(true) - 1);
    };

    model.fixedHeight = function () {
        return model.height(0, grid.rowModel.numFixed() - 1);
    };

    model.fixedWidth = function () {
        return model.width(0, grid.colModel.numFixed() - 1);
    };

    function sizeChangeListener() {
        //for now we don't cache anything about this so we just notify
        grid.eventLoop.fire('grid-virtual-pixel-cell-change');
    }

    grid.eventLoop.bind('grid-col-change', sizeChangeListener);
    grid.eventLoop.bind('grid-row-change', sizeChangeListener);

    return model;
};
},{"../util":42}]},{},[1])
;


//# sourceMappingURL=grid.js.map